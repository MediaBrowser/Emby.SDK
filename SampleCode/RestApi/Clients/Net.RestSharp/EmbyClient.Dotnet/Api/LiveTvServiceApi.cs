/*
 * EmbyClient.Dotnet
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using EmbyClient.Dotnet.Client;
using EmbyClient.Dotnet.Model;

namespace EmbyClient.Dotnet.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public interface ILiveTvServiceApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns></returns>
        void DeleteLivetvChannelmappingoptions (string providerId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteLivetvChannelmappingoptionsWithHttpInfo (string providerId);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns></returns>
        void DeleteLivetvChannelmappings (string providerId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteLivetvChannelmappingsWithHttpInfo (string providerId);
        /// <summary>
        /// Deletes a listing provider
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Provider id (optional)</param>
        /// <returns></returns>
        void DeleteLivetvListingproviders (string id);

        /// <summary>
        /// Deletes a listing provider
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Provider id (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteLivetvListingprovidersWithHttpInfo (string id);
        /// <summary>
        /// Deletes a live tv recording
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Recording Id</param>
        /// <returns></returns>
        void DeleteLivetvRecordingsById (string id);

        /// <summary>
        /// Deletes a live tv recording
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Recording Id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteLivetvRecordingsByIdWithHttpInfo (string id);
        /// <summary>
        /// Cancels a live tv series timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns></returns>
        void DeleteLivetvSeriestimersById (string id);

        /// <summary>
        /// Cancels a live tv series timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteLivetvSeriestimersByIdWithHttpInfo (string id);
        /// <summary>
        /// Cancels a live tv timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns></returns>
        void DeleteLivetvTimersById (string id);

        /// <summary>
        /// Cancels a live tv timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteLivetvTimersByIdWithHttpInfo (string id);
        /// <summary>
        /// Deletes a tuner host
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Tuner host id (optional)</param>
        /// <returns></returns>
        void DeleteLivetvTunerhosts (string id);

        /// <summary>
        /// Deletes a tuner host
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Tuner host id (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteLivetvTunerhostsWithHttpInfo (string id);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns></returns>
        void GetLivetvChannelmappingoptions (string providerId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> GetLivetvChannelmappingoptionsWithHttpInfo (string providerId);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns></returns>
        void GetLivetvChannelmappings (string providerId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> GetLivetvChannelmappingsWithHttpInfo (string providerId);
        /// <summary>
        /// Gets available live tv channels.
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">Optional filter by channel type. (optional)</param>
        /// <param name="isLiked">Filter by channels that are liked, or not. (optional)</param>
        /// <param name="isDisliked">Filter by channels that are disliked, or not. (optional)</param>
        /// <param name="enableFavoriteSorting">Incorporate favorite and like status into channel sorting. (optional)</param>
        /// <param name="addCurrentProgram">Optional. Adds current program info to each channel (optional)</param>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>QueryResultBaseItemDto</returns>
        QueryResultBaseItemDto GetLivetvChannels (LiveTvChannelType type, bool? isLiked, bool? isDisliked, bool? enableFavoriteSorting, bool? addCurrentProgram, string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan);

        /// <summary>
        /// Gets available live tv channels.
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">Optional filter by channel type. (optional)</param>
        /// <param name="isLiked">Filter by channels that are liked, or not. (optional)</param>
        /// <param name="isDisliked">Filter by channels that are disliked, or not. (optional)</param>
        /// <param name="enableFavoriteSorting">Incorporate favorite and like status into channel sorting. (optional)</param>
        /// <param name="addCurrentProgram">Optional. Adds current program info to each channel (optional)</param>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>ApiResponse of QueryResultBaseItemDto</returns>
        ApiResponse<QueryResultBaseItemDto> GetLivetvChannelsWithHttpInfo (LiveTvChannelType type, bool? isLiked, bool? isDisliked, bool? enableFavoriteSorting, bool? addCurrentProgram, string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan);
        /// <summary>
        /// Gets a live tv channel
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Channel Id</param>
        /// <param name="userId">Optional attach user data. (optional)</param>
        /// <returns>BaseItemDto</returns>
        BaseItemDto GetLivetvChannelsById (string id, string userId);

        /// <summary>
        /// Gets a live tv channel
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Channel Id</param>
        /// <param name="userId">Optional attach user data. (optional)</param>
        /// <returns>ApiResponse of BaseItemDto</returns>
        ApiResponse<BaseItemDto> GetLivetvChannelsByIdWithHttpInfo (string id, string userId);
        /// <summary>
        /// Gets live tv channel tags
        /// </summary>
        /// <remarks>
        /// No authentication required
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>QueryResultBaseItemDto</returns>
        QueryResultBaseItemDto GetLivetvChanneltags (string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan);

        /// <summary>
        /// Gets live tv channel tags
        /// </summary>
        /// <remarks>
        /// No authentication required
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>ApiResponse of QueryResultBaseItemDto</returns>
        ApiResponse<QueryResultBaseItemDto> GetLivetvChanneltagsWithHttpInfo (string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan);
        /// <summary>
        /// Gets live tv channel tag prefixes
        /// </summary>
        /// <remarks>
        /// No authentication required
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>List&lt;LiveTVApiTagItem&gt;</returns>
        List<LiveTVApiTagItem> GetLivetvChanneltagsPrefixes (string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan);

        /// <summary>
        /// Gets live tv channel tag prefixes
        /// </summary>
        /// <remarks>
        /// No authentication required
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>ApiResponse of List&lt;LiveTVApiTagItem&gt;</returns>
        ApiResponse<List<LiveTVApiTagItem>> GetLivetvChanneltagsPrefixesWithHttpInfo (string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan);
        /// <summary>
        /// Gets the epg.
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">Optional filter by channel type. (optional)</param>
        /// <param name="userId">Optional filter by user and attach user data. (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="minStartDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxStartDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minEndDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxEndDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="isFavorite">Filter by channels that are favorites, or not. (optional)</param>
        /// <param name="isLiked">Filter by channels that are liked, or not. (optional)</param>
        /// <param name="isDisliked">Filter by channels that are disliked, or not. (optional)</param>
        /// <param name="enableFavoriteSorting">Incorporate favorite and like status into channel sorting. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="addCurrentProgram">Optional. Adds current program info to each channel (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="channelIds">The channels to return guide information for. (optional)</param>
        /// <returns>QueryResultLiveTVApiEpgRow</returns>
        QueryResultLiveTVApiEpgRow GetLivetvEPG (LiveTvChannelType type, string userId, string genreIds, string minStartDate, string maxStartDate, string minEndDate, string maxEndDate, int? startIndex, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, int? limit, bool? isFavorite, bool? isLiked, bool? isDisliked, bool? enableFavoriteSorting, bool? enableImages, int? imageTypeLimit, string enableImageTypes, string fields, bool? addCurrentProgram, bool? enableUserData, string channelIds);

        /// <summary>
        /// Gets the epg.
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">Optional filter by channel type. (optional)</param>
        /// <param name="userId">Optional filter by user and attach user data. (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="minStartDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxStartDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minEndDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxEndDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="isFavorite">Filter by channels that are favorites, or not. (optional)</param>
        /// <param name="isLiked">Filter by channels that are liked, or not. (optional)</param>
        /// <param name="isDisliked">Filter by channels that are disliked, or not. (optional)</param>
        /// <param name="enableFavoriteSorting">Incorporate favorite and like status into channel sorting. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="addCurrentProgram">Optional. Adds current program info to each channel (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="channelIds">The channels to return guide information for. (optional)</param>
        /// <returns>ApiResponse of QueryResultLiveTVApiEpgRow</returns>
        ApiResponse<QueryResultLiveTVApiEpgRow> GetLivetvEPGWithHttpInfo (LiveTvChannelType type, string userId, string genreIds, string minStartDate, string maxStartDate, string minEndDate, string maxEndDate, int? startIndex, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, int? limit, bool? isFavorite, bool? isLiked, bool? isDisliked, bool? enableFavoriteSorting, bool? enableImages, int? imageTypeLimit, string enableImageTypes, string fields, bool? addCurrentProgram, bool? enableUserData, string channelIds);
        /// <summary>
        /// Gets the top level live tv folder
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>BaseItemDto</returns>
        BaseItemDto GetLivetvFolder ();

        /// <summary>
        /// Gets the top level live tv folder
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of BaseItemDto</returns>
        ApiResponse<BaseItemDto> GetLivetvFolderWithHttpInfo ();
        /// <summary>
        /// Gets guide info
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>LiveTvGuideInfo</returns>
        LiveTvGuideInfo GetLivetvGuideinfo ();

        /// <summary>
        /// Gets guide info
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of LiveTvGuideInfo</returns>
        ApiResponse<LiveTvGuideInfo> GetLivetvGuideinfoWithHttpInfo ();
        /// <summary>
        /// Gets available live tv services.
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>LiveTvLiveTvInfo</returns>
        LiveTvLiveTvInfo GetLivetvInfo ();

        /// <summary>
        /// Gets available live tv services.
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of LiveTvLiveTvInfo</returns>
        ApiResponse<LiveTvLiveTvInfo> GetLivetvInfoWithHttpInfo ();
        /// <summary>
        /// Gets current listing providers
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">Channel id</param>
        /// <returns>List&lt;LiveTvListingsProviderInfo&gt;</returns>
        List<LiveTvListingsProviderInfo> GetLivetvListingproviders (string channelId);

        /// <summary>
        /// Gets current listing providers
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">Channel id</param>
        /// <returns>ApiResponse of List&lt;LiveTvListingsProviderInfo&gt;</returns>
        ApiResponse<List<LiveTvListingsProviderInfo>> GetLivetvListingprovidersWithHttpInfo (string channelId);
        /// <summary>
        /// Gets listing provider
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>List&lt;LiveTVApiListingProviderTypeInfo&gt;</returns>
        List<LiveTVApiListingProviderTypeInfo> GetLivetvListingprovidersAvailable ();

        /// <summary>
        /// Gets listing provider
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of List&lt;LiveTVApiListingProviderTypeInfo&gt;</returns>
        ApiResponse<List<LiveTVApiListingProviderTypeInfo>> GetLivetvListingprovidersAvailableWithHttpInfo ();
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>LiveTvListingsProviderInfo</returns>
        LiveTvListingsProviderInfo GetLivetvListingprovidersDefault ();

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of LiveTvListingsProviderInfo</returns>
        ApiResponse<LiveTvListingsProviderInfo> GetLivetvListingprovidersDefaultWithHttpInfo ();
        /// <summary>
        /// Gets available lineups
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Provider id (optional)</param>
        /// <param name="type">Provider Type (optional)</param>
        /// <param name="location">Location (optional)</param>
        /// <param name="country">Country (optional)</param>
        /// <returns>List&lt;NameIdPair&gt;</returns>
        List<NameIdPair> GetLivetvListingprovidersLineups (string id, string type, string location, string country);

        /// <summary>
        /// Gets available lineups
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Provider id (optional)</param>
        /// <param name="type">Provider Type (optional)</param>
        /// <param name="location">Location (optional)</param>
        /// <param name="country">Country (optional)</param>
        /// <returns>ApiResponse of List&lt;NameIdPair&gt;</returns>
        ApiResponse<List<NameIdPair>> GetLivetvListingprovidersLineupsWithHttpInfo (string id, string type, string location, string country);
        /// <summary>
        /// Gets available lineups
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns></returns>
        void GetLivetvListingprovidersSchedulesdirectCountries ();

        /// <summary>
        /// Gets available lineups
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> GetLivetvListingprovidersSchedulesdirectCountriesWithHttpInfo ();
        /// <summary>
        /// Gets a live tv channel
        /// </summary>
        /// <remarks>
        /// No authentication required
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns></returns>
        void GetLivetvLiverecordingsByIdStream (string id);

        /// <summary>
        /// Gets a live tv channel
        /// </summary>
        /// <remarks>
        /// No authentication required
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> GetLivetvLiverecordingsByIdStreamWithHttpInfo (string id);
        /// <summary>
        /// Gets a live tv channel
        /// </summary>
        /// <remarks>
        /// No authentication required
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="container"></param>
        /// <returns></returns>
        void GetLivetvLivestreamfilesByIdStreamByContainer (string id, string container);

        /// <summary>
        /// Gets a live tv channel
        /// </summary>
        /// <remarks>
        /// No authentication required
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="container"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> GetLivetvLivestreamfilesByIdStreamByContainerWithHttpInfo (string id, string container);
        /// <summary>
        /// Gets the channel management list
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <returns>QueryResultEmbyLiveTVChannelManagementInfo</returns>
        QueryResultEmbyLiveTVChannelManagementInfo GetLivetvManageChannels (int? startIndex, int? limit, string sortBy, string sortOrder);

        /// <summary>
        /// Gets the channel management list
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <returns>ApiResponse of QueryResultEmbyLiveTVChannelManagementInfo</returns>
        ApiResponse<QueryResultEmbyLiveTVChannelManagementInfo> GetLivetvManageChannelsWithHttpInfo (int? startIndex, int? limit, string sortBy, string sortOrder);
        /// <summary>
        /// Gets available live tv epgs..
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelIds">The channels to return guide information for. (optional)</param>
        /// <param name="userId">Optional filter by user id. (optional)</param>
        /// <param name="hasAired">Optional. Filter by programs that have completed airing, or not. (optional)</param>
        /// <param name="minStartDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxStartDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minEndDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxEndDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <returns>QueryResultBaseItemDto</returns>
        QueryResultBaseItemDto GetLivetvPrograms (string channelIds, string userId, bool? hasAired, string minStartDate, string maxStartDate, string minEndDate, string maxEndDate, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, int? startIndex, int? limit, string sortBy, string sortOrder, string genreIds, bool? enableImages, int? imageTypeLimit, string enableImageTypes, bool? enableUserData, string fields);

        /// <summary>
        /// Gets available live tv epgs..
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelIds">The channels to return guide information for. (optional)</param>
        /// <param name="userId">Optional filter by user id. (optional)</param>
        /// <param name="hasAired">Optional. Filter by programs that have completed airing, or not. (optional)</param>
        /// <param name="minStartDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxStartDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minEndDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxEndDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <returns>ApiResponse of QueryResultBaseItemDto</returns>
        ApiResponse<QueryResultBaseItemDto> GetLivetvProgramsWithHttpInfo (string channelIds, string userId, bool? hasAired, string minStartDate, string maxStartDate, string minEndDate, string maxEndDate, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, int? startIndex, int? limit, string sortBy, string sortOrder, string genreIds, bool? enableImages, int? imageTypeLimit, string enableImageTypes, bool? enableUserData, string fields);
        /// <summary>
        /// Gets available live tv epgs..
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">Optional filter by user id. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="isAiring">Optional. Filter by programs that are currently airing, or not. (optional)</param>
        /// <param name="hasAired">Optional. Filter by programs that have completed airing, or not. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <returns>QueryResultBaseItemDto</returns>
        QueryResultBaseItemDto GetLivetvProgramsRecommended (string userId, int? limit, bool? isAiring, bool? hasAired, bool? isSeries, bool? isMovie, bool? isNews, bool? isKids, bool? isSports, bool? enableImages, int? imageTypeLimit, string enableImageTypes, string genreIds, string fields, bool? enableUserData);

        /// <summary>
        /// Gets available live tv epgs..
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">Optional filter by user id. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="isAiring">Optional. Filter by programs that are currently airing, or not. (optional)</param>
        /// <param name="hasAired">Optional. Filter by programs that have completed airing, or not. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <returns>ApiResponse of QueryResultBaseItemDto</returns>
        ApiResponse<QueryResultBaseItemDto> GetLivetvProgramsRecommendedWithHttpInfo (string userId, int? limit, bool? isAiring, bool? hasAired, bool? isSeries, bool? isMovie, bool? isNews, bool? isKids, bool? isSports, bool? enableImages, int? imageTypeLimit, string enableImageTypes, string genreIds, string fields, bool? enableUserData);
        /// <summary>
        /// Gets live tv recordings
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">Optional filter by channel id. (optional)</param>
        /// <param name="status">Optional filter by recording status. (optional)</param>
        /// <param name="isInProgress">Optional filter by recordings that are in progress, or not. (optional)</param>
        /// <param name="seriesTimerId">Optional filter by recordings belonging to a series timer (optional)</param>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns></returns>
        void GetLivetvRecordings (string channelId, LiveTvRecordingStatus status, bool? isInProgress, string seriesTimerId, string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan);

        /// <summary>
        /// Gets live tv recordings
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">Optional filter by channel id. (optional)</param>
        /// <param name="status">Optional filter by recording status. (optional)</param>
        /// <param name="isInProgress">Optional filter by recordings that are in progress, or not. (optional)</param>
        /// <param name="seriesTimerId">Optional filter by recordings belonging to a series timer (optional)</param>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> GetLivetvRecordingsWithHttpInfo (string channelId, LiveTvRecordingStatus status, bool? isInProgress, string seriesTimerId, string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan);
        /// <summary>
        /// Gets a live tv recording
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Recording Id</param>
        /// <param name="userId">Optional attach user data. (optional)</param>
        /// <returns>BaseItemDto</returns>
        BaseItemDto GetLivetvRecordingsById (string id, string userId);

        /// <summary>
        /// Gets a live tv recording
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Recording Id</param>
        /// <param name="userId">Optional attach user data. (optional)</param>
        /// <returns>ApiResponse of BaseItemDto</returns>
        ApiResponse<BaseItemDto> GetLivetvRecordingsByIdWithHttpInfo (string id, string userId);
        /// <summary>
        /// Gets recording folders
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">Optional filter by user and attach user data. (optional)</param>
        /// <returns>List&lt;BaseItemDto&gt;</returns>
        List<BaseItemDto> GetLivetvRecordingsFolders (string userId);

        /// <summary>
        /// Gets recording folders
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">Optional filter by user and attach user data. (optional)</param>
        /// <returns>ApiResponse of List&lt;BaseItemDto&gt;</returns>
        ApiResponse<List<BaseItemDto>> GetLivetvRecordingsFoldersWithHttpInfo (string userId);
        /// <summary>
        /// Gets live tv recording groups
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>QueryResultBaseItemDto</returns>
        QueryResultBaseItemDto GetLivetvRecordingsGroups ();

        /// <summary>
        /// Gets live tv recording groups
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of QueryResultBaseItemDto</returns>
        ApiResponse<QueryResultBaseItemDto> GetLivetvRecordingsGroupsWithHttpInfo ();
        /// <summary>
        /// Gets live tv recordings
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>QueryResultBaseItemDto</returns>
        QueryResultBaseItemDto GetLivetvRecordingsSeries ();

        /// <summary>
        /// Gets live tv recordings
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of QueryResultBaseItemDto</returns>
        ApiResponse<QueryResultBaseItemDto> GetLivetvRecordingsSeriesWithHttpInfo ();
        /// <summary>
        /// Gets live tv series timers
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Optional. Sort by SortName or Priority (optional)</param>
        /// <param name="sortOrder">Optional. Sort in Ascending or Descending order (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <returns>QueryResultLiveTvSeriesTimerInfoDto</returns>
        QueryResultLiveTvSeriesTimerInfoDto GetLivetvSeriestimers (string sortBy, SortOrder sortOrder, int? startIndex, int? limit);

        /// <summary>
        /// Gets live tv series timers
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Optional. Sort by SortName or Priority (optional)</param>
        /// <param name="sortOrder">Optional. Sort in Ascending or Descending order (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <returns>ApiResponse of QueryResultLiveTvSeriesTimerInfoDto</returns>
        ApiResponse<QueryResultLiveTvSeriesTimerInfoDto> GetLivetvSeriestimersWithHttpInfo (string sortBy, SortOrder sortOrder, int? startIndex, int? limit);
        /// <summary>
        /// Gets a live tv series timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>LiveTvTimerInfoDto</returns>
        LiveTvTimerInfoDto GetLivetvSeriestimersById (string id);

        /// <summary>
        /// Gets a live tv series timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>ApiResponse of LiveTvTimerInfoDto</returns>
        ApiResponse<LiveTvTimerInfoDto> GetLivetvSeriestimersByIdWithHttpInfo (string id);
        /// <summary>
        /// Gets live tv timers
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">Optional filter by channel id. (optional)</param>
        /// <param name="seriesTimerId">Optional filter by timers belonging to a series timer (optional)</param>
        /// <returns>QueryResultLiveTvTimerInfoDto</returns>
        QueryResultLiveTvTimerInfoDto GetLivetvTimers (string channelId, string seriesTimerId);

        /// <summary>
        /// Gets live tv timers
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">Optional filter by channel id. (optional)</param>
        /// <param name="seriesTimerId">Optional filter by timers belonging to a series timer (optional)</param>
        /// <returns>ApiResponse of QueryResultLiveTvTimerInfoDto</returns>
        ApiResponse<QueryResultLiveTvTimerInfoDto> GetLivetvTimersWithHttpInfo (string channelId, string seriesTimerId);
        /// <summary>
        /// Gets a live tv timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>LiveTvTimerInfoDto</returns>
        LiveTvTimerInfoDto GetLivetvTimersById (string id);

        /// <summary>
        /// Gets a live tv timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>ApiResponse of LiveTvTimerInfoDto</returns>
        ApiResponse<LiveTvTimerInfoDto> GetLivetvTimersByIdWithHttpInfo (string id);
        /// <summary>
        /// Gets default values for a new timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="programId">Optional, to attach default values based on a program. (optional)</param>
        /// <returns>LiveTvSeriesTimerInfoDto</returns>
        LiveTvSeriesTimerInfoDto GetLivetvTimersDefaults (string programId);

        /// <summary>
        /// Gets default values for a new timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="programId">Optional, to attach default values based on a program. (optional)</param>
        /// <returns>ApiResponse of LiveTvSeriesTimerInfoDto</returns>
        ApiResponse<LiveTvSeriesTimerInfoDto> GetLivetvTimersDefaultsWithHttpInfo (string programId);
        /// <summary>
        /// Gets tuner hosts
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>List&lt;LiveTvTunerHostInfo&gt;</returns>
        List<LiveTvTunerHostInfo> GetLivetvTunerhosts ();

        /// <summary>
        /// Gets tuner hosts
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of List&lt;LiveTvTunerHostInfo&gt;</returns>
        ApiResponse<List<LiveTvTunerHostInfo>> GetLivetvTunerhostsWithHttpInfo ();
        /// <summary>
        /// Gets tuner hosts
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">Type</param>
        /// <returns>LiveTvTunerHostInfo</returns>
        LiveTvTunerHostInfo GetLivetvTunerhostsDefaultByType (string type);

        /// <summary>
        /// Gets tuner hosts
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">Type</param>
        /// <returns>ApiResponse of LiveTvTunerHostInfo</returns>
        ApiResponse<LiveTvTunerHostInfo> GetLivetvTunerhostsDefaultByTypeWithHttpInfo (string type);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>List&lt;NameIdPair&gt;</returns>
        List<NameIdPair> GetLivetvTunerhostsTypes ();

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of List&lt;NameIdPair&gt;</returns>
        ApiResponse<List<NameIdPair>> GetLivetvTunerhostsTypesWithHttpInfo ();
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>List&lt;LiveTvTunerHostInfo&gt;</returns>
        List<LiveTvTunerHostInfo> GetLivetvTunersDiscvover ();

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of List&lt;LiveTvTunerHostInfo&gt;</returns>
        ApiResponse<List<LiveTvTunerHostInfo>> GetLivetvTunersDiscvoverWithHttpInfo ();
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns></returns>
        void HeadLivetvChannelmappingoptions (string providerId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> HeadLivetvChannelmappingoptionsWithHttpInfo (string providerId);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns></returns>
        void HeadLivetvChannelmappings (string providerId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> HeadLivetvChannelmappingsWithHttpInfo (string providerId);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns></returns>
        void PostLivetvChannelmappingoptions (string providerId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> PostLivetvChannelmappingoptionsWithHttpInfo (string providerId);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelMapping</param>
        /// <param name="providerId">Provider id</param>
        /// <returns></returns>
        void PostLivetvChannelmappings (LiveTVApiSetChannelMapping body, string providerId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelMapping</param>
        /// <param name="providerId">Provider id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> PostLivetvChannelmappingsWithHttpInfo (LiveTVApiSetChannelMapping body, string providerId);
        /// <summary>
        /// Adds a listing provider
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">ListingsProviderInfo: </param>
        /// <returns>LiveTvListingsProviderInfo</returns>
        LiveTvListingsProviderInfo PostLivetvListingproviders (LiveTvListingsProviderInfo body);

        /// <summary>
        /// Adds a listing provider
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">ListingsProviderInfo: </param>
        /// <returns>ApiResponse of LiveTvListingsProviderInfo</returns>
        ApiResponse<LiveTvListingsProviderInfo> PostLivetvListingprovidersWithHttpInfo (LiveTvListingsProviderInfo body);
        /// <summary>
        /// Deletes a listing provider
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Provider id (optional)</param>
        /// <returns></returns>
        void PostLivetvListingprovidersDelete (string id);

        /// <summary>
        /// Deletes a listing provider
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Provider id (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> PostLivetvListingprovidersDeleteWithHttpInfo (string id);
        /// <summary>
        /// Sets a channel disabled or not
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelDisabled</param>
        /// <param name="id"></param>
        /// <returns>QueryResultEmbyLiveTVChannelManagementInfo</returns>
        QueryResultEmbyLiveTVChannelManagementInfo PostLivetvManageChannelsByIdDisabled (LiveTVApiSetChannelDisabled body, string id);

        /// <summary>
        /// Sets a channel disabled or not
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelDisabled</param>
        /// <param name="id"></param>
        /// <returns>ApiResponse of QueryResultEmbyLiveTVChannelManagementInfo</returns>
        ApiResponse<QueryResultEmbyLiveTVChannelManagementInfo> PostLivetvManageChannelsByIdDisabledWithHttpInfo (LiveTVApiSetChannelDisabled body, string id);
        /// <summary>
        /// Sets a channel sort index
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelSortIndex</param>
        /// <param name="id"></param>
        /// <returns>QueryResultEmbyLiveTVChannelManagementInfo</returns>
        QueryResultEmbyLiveTVChannelManagementInfo PostLivetvManageChannelsByIdSortindex (LiveTVApiSetChannelSortIndex body, string id);

        /// <summary>
        /// Sets a channel sort index
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelSortIndex</param>
        /// <param name="id"></param>
        /// <returns>ApiResponse of QueryResultEmbyLiveTVChannelManagementInfo</returns>
        ApiResponse<QueryResultEmbyLiveTVChannelManagementInfo> PostLivetvManageChannelsByIdSortindexWithHttpInfo (LiveTVApiSetChannelSortIndex body, string id);
        /// <summary>
        /// Gets available live tv epgs..
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">GetPrograms</param>
        /// <param name="channelIds">The channels to return guide information for. (optional)</param>
        /// <param name="userId">Optional filter by user id. (optional)</param>
        /// <param name="hasAired">Optional. Filter by programs that have completed airing, or not. (optional)</param>
        /// <param name="minStartDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxStartDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minEndDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxEndDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <returns>QueryResultBaseItemDto</returns>
        QueryResultBaseItemDto PostLivetvPrograms (LiveTVApiGetPrograms body, string channelIds, string userId, bool? hasAired, string minStartDate, string maxStartDate, string minEndDate, string maxEndDate, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, int? startIndex, int? limit, string sortBy, string sortOrder, string genreIds, bool? enableImages, int? imageTypeLimit, string enableImageTypes, bool? enableUserData, string fields);

        /// <summary>
        /// Gets available live tv epgs..
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">GetPrograms</param>
        /// <param name="channelIds">The channels to return guide information for. (optional)</param>
        /// <param name="userId">Optional filter by user id. (optional)</param>
        /// <param name="hasAired">Optional. Filter by programs that have completed airing, or not. (optional)</param>
        /// <param name="minStartDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxStartDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minEndDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxEndDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <returns>ApiResponse of QueryResultBaseItemDto</returns>
        ApiResponse<QueryResultBaseItemDto> PostLivetvProgramsWithHttpInfo (LiveTVApiGetPrograms body, string channelIds, string userId, bool? hasAired, string minStartDate, string maxStartDate, string minEndDate, string maxEndDate, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, int? startIndex, int? limit, string sortBy, string sortOrder, string genreIds, bool? enableImages, int? imageTypeLimit, string enableImageTypes, bool? enableUserData, string fields);
        /// <summary>
        /// Deletes a live tv recording
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Recording Id</param>
        /// <returns></returns>
        void PostLivetvRecordingsByIdDelete (string id);

        /// <summary>
        /// Deletes a live tv recording
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Recording Id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> PostLivetvRecordingsByIdDeleteWithHttpInfo (string id);
        /// <summary>
        /// Creates a live tv series timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SeriesTimerInfo: </param>
        /// <returns></returns>
        void PostLivetvSeriestimers (LiveTvSeriesTimerInfo body);

        /// <summary>
        /// Creates a live tv series timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SeriesTimerInfo: </param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> PostLivetvSeriestimersWithHttpInfo (LiveTvSeriesTimerInfo body);
        /// <summary>
        /// Updates a live tv series timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SeriesTimerInfo: </param>
        /// <param name="id"></param>
        /// <returns></returns>
        void PostLivetvSeriestimersById (LiveTvSeriesTimerInfo body, string id);

        /// <summary>
        /// Updates a live tv series timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SeriesTimerInfo: </param>
        /// <param name="id"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> PostLivetvSeriestimersByIdWithHttpInfo (LiveTvSeriesTimerInfo body, string id);
        /// <summary>
        /// Cancels a live tv series timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns></returns>
        void PostLivetvSeriestimersByIdDelete (string id);

        /// <summary>
        /// Cancels a live tv series timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> PostLivetvSeriestimersByIdDeleteWithHttpInfo (string id);
        /// <summary>
        /// Creates a live tv timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">TimerInfoDto: </param>
        /// <returns></returns>
        void PostLivetvTimers (LiveTvTimerInfoDto body);

        /// <summary>
        /// Creates a live tv timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">TimerInfoDto: </param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> PostLivetvTimersWithHttpInfo (LiveTvTimerInfoDto body);
        /// <summary>
        /// Updates a live tv timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">TimerInfoDto: </param>
        /// <param name="id"></param>
        /// <returns></returns>
        void PostLivetvTimersById (LiveTvTimerInfoDto body, string id);

        /// <summary>
        /// Updates a live tv timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">TimerInfoDto: </param>
        /// <param name="id"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> PostLivetvTimersByIdWithHttpInfo (LiveTvTimerInfoDto body, string id);
        /// <summary>
        /// Cancels a live tv timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns></returns>
        void PostLivetvTimersByIdDelete (string id);

        /// <summary>
        /// Cancels a live tv timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> PostLivetvTimersByIdDeleteWithHttpInfo (string id);
        /// <summary>
        /// Adds a tuner host
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">TunerHostInfo: </param>
        /// <returns>LiveTvTunerHostInfo</returns>
        LiveTvTunerHostInfo PostLivetvTunerhosts (LiveTvTunerHostInfo body);

        /// <summary>
        /// Adds a tuner host
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">TunerHostInfo: </param>
        /// <returns>ApiResponse of LiveTvTunerHostInfo</returns>
        ApiResponse<LiveTvTunerHostInfo> PostLivetvTunerhostsWithHttpInfo (LiveTvTunerHostInfo body);
        /// <summary>
        /// Deletes a tuner host
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Tuner host id (optional)</param>
        /// <returns></returns>
        void PostLivetvTunerhostsDelete (string id);

        /// <summary>
        /// Deletes a tuner host
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Tuner host id (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> PostLivetvTunerhostsDeleteWithHttpInfo (string id);
        /// <summary>
        /// Resets a tv tuner
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Tuner Id</param>
        /// <returns></returns>
        void PostLivetvTunersByIdReset (string id);

        /// <summary>
        /// Resets a tv tuner
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Tuner Id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> PostLivetvTunersByIdResetWithHttpInfo (string id);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns></returns>
        void PutLivetvChannelmappingoptions (string providerId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> PutLivetvChannelmappingoptionsWithHttpInfo (string providerId);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelMapping</param>
        /// <param name="providerId">Provider id</param>
        /// <returns></returns>
        void PutLivetvChannelmappings (LiveTVApiSetChannelMapping body, string providerId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelMapping</param>
        /// <param name="providerId">Provider id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> PutLivetvChannelmappingsWithHttpInfo (LiveTVApiSetChannelMapping body, string providerId);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteLivetvChannelmappingoptionsAsync (string providerId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteLivetvChannelmappingoptionsAsyncWithHttpInfo (string providerId);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteLivetvChannelmappingsAsync (string providerId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteLivetvChannelmappingsAsyncWithHttpInfo (string providerId);
        /// <summary>
        /// Deletes a listing provider
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Provider id (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteLivetvListingprovidersAsync (string id);

        /// <summary>
        /// Deletes a listing provider
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Provider id (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteLivetvListingprovidersAsyncWithHttpInfo (string id);
        /// <summary>
        /// Deletes a live tv recording
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Recording Id</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteLivetvRecordingsByIdAsync (string id);

        /// <summary>
        /// Deletes a live tv recording
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Recording Id</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteLivetvRecordingsByIdAsyncWithHttpInfo (string id);
        /// <summary>
        /// Cancels a live tv series timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteLivetvSeriestimersByIdAsync (string id);

        /// <summary>
        /// Cancels a live tv series timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteLivetvSeriestimersByIdAsyncWithHttpInfo (string id);
        /// <summary>
        /// Cancels a live tv timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteLivetvTimersByIdAsync (string id);

        /// <summary>
        /// Cancels a live tv timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteLivetvTimersByIdAsyncWithHttpInfo (string id);
        /// <summary>
        /// Deletes a tuner host
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Tuner host id (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteLivetvTunerhostsAsync (string id);

        /// <summary>
        /// Deletes a tuner host
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Tuner host id (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteLivetvTunerhostsAsyncWithHttpInfo (string id);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task GetLivetvChannelmappingoptionsAsync (string providerId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> GetLivetvChannelmappingoptionsAsyncWithHttpInfo (string providerId);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task GetLivetvChannelmappingsAsync (string providerId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> GetLivetvChannelmappingsAsyncWithHttpInfo (string providerId);
        /// <summary>
        /// Gets available live tv channels.
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">Optional filter by channel type. (optional)</param>
        /// <param name="isLiked">Filter by channels that are liked, or not. (optional)</param>
        /// <param name="isDisliked">Filter by channels that are disliked, or not. (optional)</param>
        /// <param name="enableFavoriteSorting">Incorporate favorite and like status into channel sorting. (optional)</param>
        /// <param name="addCurrentProgram">Optional. Adds current program info to each channel (optional)</param>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>Task of QueryResultBaseItemDto</returns>
        System.Threading.Tasks.Task<QueryResultBaseItemDto> GetLivetvChannelsAsync (LiveTvChannelType type, bool? isLiked, bool? isDisliked, bool? enableFavoriteSorting, bool? addCurrentProgram, string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan);

        /// <summary>
        /// Gets available live tv channels.
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">Optional filter by channel type. (optional)</param>
        /// <param name="isLiked">Filter by channels that are liked, or not. (optional)</param>
        /// <param name="isDisliked">Filter by channels that are disliked, or not. (optional)</param>
        /// <param name="enableFavoriteSorting">Incorporate favorite and like status into channel sorting. (optional)</param>
        /// <param name="addCurrentProgram">Optional. Adds current program info to each channel (optional)</param>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>Task of ApiResponse (QueryResultBaseItemDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<QueryResultBaseItemDto>> GetLivetvChannelsAsyncWithHttpInfo (LiveTvChannelType type, bool? isLiked, bool? isDisliked, bool? enableFavoriteSorting, bool? addCurrentProgram, string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan);
        /// <summary>
        /// Gets a live tv channel
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Channel Id</param>
        /// <param name="userId">Optional attach user data. (optional)</param>
        /// <returns>Task of BaseItemDto</returns>
        System.Threading.Tasks.Task<BaseItemDto> GetLivetvChannelsByIdAsync (string id, string userId);

        /// <summary>
        /// Gets a live tv channel
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Channel Id</param>
        /// <param name="userId">Optional attach user data. (optional)</param>
        /// <returns>Task of ApiResponse (BaseItemDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<BaseItemDto>> GetLivetvChannelsByIdAsyncWithHttpInfo (string id, string userId);
        /// <summary>
        /// Gets live tv channel tags
        /// </summary>
        /// <remarks>
        /// No authentication required
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>Task of QueryResultBaseItemDto</returns>
        System.Threading.Tasks.Task<QueryResultBaseItemDto> GetLivetvChanneltagsAsync (string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan);

        /// <summary>
        /// Gets live tv channel tags
        /// </summary>
        /// <remarks>
        /// No authentication required
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>Task of ApiResponse (QueryResultBaseItemDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<QueryResultBaseItemDto>> GetLivetvChanneltagsAsyncWithHttpInfo (string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan);
        /// <summary>
        /// Gets live tv channel tag prefixes
        /// </summary>
        /// <remarks>
        /// No authentication required
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>Task of List&lt;LiveTVApiTagItem&gt;</returns>
        System.Threading.Tasks.Task<List<LiveTVApiTagItem>> GetLivetvChanneltagsPrefixesAsync (string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan);

        /// <summary>
        /// Gets live tv channel tag prefixes
        /// </summary>
        /// <remarks>
        /// No authentication required
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;LiveTVApiTagItem&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<LiveTVApiTagItem>>> GetLivetvChanneltagsPrefixesAsyncWithHttpInfo (string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan);
        /// <summary>
        /// Gets the epg.
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">Optional filter by channel type. (optional)</param>
        /// <param name="userId">Optional filter by user and attach user data. (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="minStartDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxStartDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minEndDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxEndDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="isFavorite">Filter by channels that are favorites, or not. (optional)</param>
        /// <param name="isLiked">Filter by channels that are liked, or not. (optional)</param>
        /// <param name="isDisliked">Filter by channels that are disliked, or not. (optional)</param>
        /// <param name="enableFavoriteSorting">Incorporate favorite and like status into channel sorting. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="addCurrentProgram">Optional. Adds current program info to each channel (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="channelIds">The channels to return guide information for. (optional)</param>
        /// <returns>Task of QueryResultLiveTVApiEpgRow</returns>
        System.Threading.Tasks.Task<QueryResultLiveTVApiEpgRow> GetLivetvEPGAsync (LiveTvChannelType type, string userId, string genreIds, string minStartDate, string maxStartDate, string minEndDate, string maxEndDate, int? startIndex, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, int? limit, bool? isFavorite, bool? isLiked, bool? isDisliked, bool? enableFavoriteSorting, bool? enableImages, int? imageTypeLimit, string enableImageTypes, string fields, bool? addCurrentProgram, bool? enableUserData, string channelIds);

        /// <summary>
        /// Gets the epg.
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">Optional filter by channel type. (optional)</param>
        /// <param name="userId">Optional filter by user and attach user data. (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="minStartDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxStartDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minEndDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxEndDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="isFavorite">Filter by channels that are favorites, or not. (optional)</param>
        /// <param name="isLiked">Filter by channels that are liked, or not. (optional)</param>
        /// <param name="isDisliked">Filter by channels that are disliked, or not. (optional)</param>
        /// <param name="enableFavoriteSorting">Incorporate favorite and like status into channel sorting. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="addCurrentProgram">Optional. Adds current program info to each channel (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="channelIds">The channels to return guide information for. (optional)</param>
        /// <returns>Task of ApiResponse (QueryResultLiveTVApiEpgRow)</returns>
        System.Threading.Tasks.Task<ApiResponse<QueryResultLiveTVApiEpgRow>> GetLivetvEPGAsyncWithHttpInfo (LiveTvChannelType type, string userId, string genreIds, string minStartDate, string maxStartDate, string minEndDate, string maxEndDate, int? startIndex, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, int? limit, bool? isFavorite, bool? isLiked, bool? isDisliked, bool? enableFavoriteSorting, bool? enableImages, int? imageTypeLimit, string enableImageTypes, string fields, bool? addCurrentProgram, bool? enableUserData, string channelIds);
        /// <summary>
        /// Gets the top level live tv folder
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of BaseItemDto</returns>
        System.Threading.Tasks.Task<BaseItemDto> GetLivetvFolderAsync ();

        /// <summary>
        /// Gets the top level live tv folder
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (BaseItemDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<BaseItemDto>> GetLivetvFolderAsyncWithHttpInfo ();
        /// <summary>
        /// Gets guide info
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of LiveTvGuideInfo</returns>
        System.Threading.Tasks.Task<LiveTvGuideInfo> GetLivetvGuideinfoAsync ();

        /// <summary>
        /// Gets guide info
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (LiveTvGuideInfo)</returns>
        System.Threading.Tasks.Task<ApiResponse<LiveTvGuideInfo>> GetLivetvGuideinfoAsyncWithHttpInfo ();
        /// <summary>
        /// Gets available live tv services.
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of LiveTvLiveTvInfo</returns>
        System.Threading.Tasks.Task<LiveTvLiveTvInfo> GetLivetvInfoAsync ();

        /// <summary>
        /// Gets available live tv services.
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (LiveTvLiveTvInfo)</returns>
        System.Threading.Tasks.Task<ApiResponse<LiveTvLiveTvInfo>> GetLivetvInfoAsyncWithHttpInfo ();
        /// <summary>
        /// Gets current listing providers
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">Channel id</param>
        /// <returns>Task of List&lt;LiveTvListingsProviderInfo&gt;</returns>
        System.Threading.Tasks.Task<List<LiveTvListingsProviderInfo>> GetLivetvListingprovidersAsync (string channelId);

        /// <summary>
        /// Gets current listing providers
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">Channel id</param>
        /// <returns>Task of ApiResponse (List&lt;LiveTvListingsProviderInfo&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<LiveTvListingsProviderInfo>>> GetLivetvListingprovidersAsyncWithHttpInfo (string channelId);
        /// <summary>
        /// Gets listing provider
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of List&lt;LiveTVApiListingProviderTypeInfo&gt;</returns>
        System.Threading.Tasks.Task<List<LiveTVApiListingProviderTypeInfo>> GetLivetvListingprovidersAvailableAsync ();

        /// <summary>
        /// Gets listing provider
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (List&lt;LiveTVApiListingProviderTypeInfo&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<LiveTVApiListingProviderTypeInfo>>> GetLivetvListingprovidersAvailableAsyncWithHttpInfo ();
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of LiveTvListingsProviderInfo</returns>
        System.Threading.Tasks.Task<LiveTvListingsProviderInfo> GetLivetvListingprovidersDefaultAsync ();

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (LiveTvListingsProviderInfo)</returns>
        System.Threading.Tasks.Task<ApiResponse<LiveTvListingsProviderInfo>> GetLivetvListingprovidersDefaultAsyncWithHttpInfo ();
        /// <summary>
        /// Gets available lineups
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Provider id (optional)</param>
        /// <param name="type">Provider Type (optional)</param>
        /// <param name="location">Location (optional)</param>
        /// <param name="country">Country (optional)</param>
        /// <returns>Task of List&lt;NameIdPair&gt;</returns>
        System.Threading.Tasks.Task<List<NameIdPair>> GetLivetvListingprovidersLineupsAsync (string id, string type, string location, string country);

        /// <summary>
        /// Gets available lineups
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Provider id (optional)</param>
        /// <param name="type">Provider Type (optional)</param>
        /// <param name="location">Location (optional)</param>
        /// <param name="country">Country (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;NameIdPair&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<NameIdPair>>> GetLivetvListingprovidersLineupsAsyncWithHttpInfo (string id, string type, string location, string country);
        /// <summary>
        /// Gets available lineups
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task GetLivetvListingprovidersSchedulesdirectCountriesAsync ();

        /// <summary>
        /// Gets available lineups
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> GetLivetvListingprovidersSchedulesdirectCountriesAsyncWithHttpInfo ();
        /// <summary>
        /// Gets a live tv channel
        /// </summary>
        /// <remarks>
        /// No authentication required
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task GetLivetvLiverecordingsByIdStreamAsync (string id);

        /// <summary>
        /// Gets a live tv channel
        /// </summary>
        /// <remarks>
        /// No authentication required
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> GetLivetvLiverecordingsByIdStreamAsyncWithHttpInfo (string id);
        /// <summary>
        /// Gets a live tv channel
        /// </summary>
        /// <remarks>
        /// No authentication required
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="container"></param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task GetLivetvLivestreamfilesByIdStreamByContainerAsync (string id, string container);

        /// <summary>
        /// Gets a live tv channel
        /// </summary>
        /// <remarks>
        /// No authentication required
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="container"></param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> GetLivetvLivestreamfilesByIdStreamByContainerAsyncWithHttpInfo (string id, string container);
        /// <summary>
        /// Gets the channel management list
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <returns>Task of QueryResultEmbyLiveTVChannelManagementInfo</returns>
        System.Threading.Tasks.Task<QueryResultEmbyLiveTVChannelManagementInfo> GetLivetvManageChannelsAsync (int? startIndex, int? limit, string sortBy, string sortOrder);

        /// <summary>
        /// Gets the channel management list
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <returns>Task of ApiResponse (QueryResultEmbyLiveTVChannelManagementInfo)</returns>
        System.Threading.Tasks.Task<ApiResponse<QueryResultEmbyLiveTVChannelManagementInfo>> GetLivetvManageChannelsAsyncWithHttpInfo (int? startIndex, int? limit, string sortBy, string sortOrder);
        /// <summary>
        /// Gets available live tv epgs..
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelIds">The channels to return guide information for. (optional)</param>
        /// <param name="userId">Optional filter by user id. (optional)</param>
        /// <param name="hasAired">Optional. Filter by programs that have completed airing, or not. (optional)</param>
        /// <param name="minStartDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxStartDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minEndDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxEndDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <returns>Task of QueryResultBaseItemDto</returns>
        System.Threading.Tasks.Task<QueryResultBaseItemDto> GetLivetvProgramsAsync (string channelIds, string userId, bool? hasAired, string minStartDate, string maxStartDate, string minEndDate, string maxEndDate, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, int? startIndex, int? limit, string sortBy, string sortOrder, string genreIds, bool? enableImages, int? imageTypeLimit, string enableImageTypes, bool? enableUserData, string fields);

        /// <summary>
        /// Gets available live tv epgs..
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelIds">The channels to return guide information for. (optional)</param>
        /// <param name="userId">Optional filter by user id. (optional)</param>
        /// <param name="hasAired">Optional. Filter by programs that have completed airing, or not. (optional)</param>
        /// <param name="minStartDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxStartDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minEndDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxEndDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <returns>Task of ApiResponse (QueryResultBaseItemDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<QueryResultBaseItemDto>> GetLivetvProgramsAsyncWithHttpInfo (string channelIds, string userId, bool? hasAired, string minStartDate, string maxStartDate, string minEndDate, string maxEndDate, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, int? startIndex, int? limit, string sortBy, string sortOrder, string genreIds, bool? enableImages, int? imageTypeLimit, string enableImageTypes, bool? enableUserData, string fields);
        /// <summary>
        /// Gets available live tv epgs..
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">Optional filter by user id. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="isAiring">Optional. Filter by programs that are currently airing, or not. (optional)</param>
        /// <param name="hasAired">Optional. Filter by programs that have completed airing, or not. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <returns>Task of QueryResultBaseItemDto</returns>
        System.Threading.Tasks.Task<QueryResultBaseItemDto> GetLivetvProgramsRecommendedAsync (string userId, int? limit, bool? isAiring, bool? hasAired, bool? isSeries, bool? isMovie, bool? isNews, bool? isKids, bool? isSports, bool? enableImages, int? imageTypeLimit, string enableImageTypes, string genreIds, string fields, bool? enableUserData);

        /// <summary>
        /// Gets available live tv epgs..
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">Optional filter by user id. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="isAiring">Optional. Filter by programs that are currently airing, or not. (optional)</param>
        /// <param name="hasAired">Optional. Filter by programs that have completed airing, or not. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <returns>Task of ApiResponse (QueryResultBaseItemDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<QueryResultBaseItemDto>> GetLivetvProgramsRecommendedAsyncWithHttpInfo (string userId, int? limit, bool? isAiring, bool? hasAired, bool? isSeries, bool? isMovie, bool? isNews, bool? isKids, bool? isSports, bool? enableImages, int? imageTypeLimit, string enableImageTypes, string genreIds, string fields, bool? enableUserData);
        /// <summary>
        /// Gets live tv recordings
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">Optional filter by channel id. (optional)</param>
        /// <param name="status">Optional filter by recording status. (optional)</param>
        /// <param name="isInProgress">Optional filter by recordings that are in progress, or not. (optional)</param>
        /// <param name="seriesTimerId">Optional filter by recordings belonging to a series timer (optional)</param>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task GetLivetvRecordingsAsync (string channelId, LiveTvRecordingStatus status, bool? isInProgress, string seriesTimerId, string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan);

        /// <summary>
        /// Gets live tv recordings
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">Optional filter by channel id. (optional)</param>
        /// <param name="status">Optional filter by recording status. (optional)</param>
        /// <param name="isInProgress">Optional filter by recordings that are in progress, or not. (optional)</param>
        /// <param name="seriesTimerId">Optional filter by recordings belonging to a series timer (optional)</param>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> GetLivetvRecordingsAsyncWithHttpInfo (string channelId, LiveTvRecordingStatus status, bool? isInProgress, string seriesTimerId, string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan);
        /// <summary>
        /// Gets a live tv recording
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Recording Id</param>
        /// <param name="userId">Optional attach user data. (optional)</param>
        /// <returns>Task of BaseItemDto</returns>
        System.Threading.Tasks.Task<BaseItemDto> GetLivetvRecordingsByIdAsync (string id, string userId);

        /// <summary>
        /// Gets a live tv recording
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Recording Id</param>
        /// <param name="userId">Optional attach user data. (optional)</param>
        /// <returns>Task of ApiResponse (BaseItemDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<BaseItemDto>> GetLivetvRecordingsByIdAsyncWithHttpInfo (string id, string userId);
        /// <summary>
        /// Gets recording folders
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">Optional filter by user and attach user data. (optional)</param>
        /// <returns>Task of List&lt;BaseItemDto&gt;</returns>
        System.Threading.Tasks.Task<List<BaseItemDto>> GetLivetvRecordingsFoldersAsync (string userId);

        /// <summary>
        /// Gets recording folders
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">Optional filter by user and attach user data. (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;BaseItemDto&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<BaseItemDto>>> GetLivetvRecordingsFoldersAsyncWithHttpInfo (string userId);
        /// <summary>
        /// Gets live tv recording groups
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of QueryResultBaseItemDto</returns>
        System.Threading.Tasks.Task<QueryResultBaseItemDto> GetLivetvRecordingsGroupsAsync ();

        /// <summary>
        /// Gets live tv recording groups
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (QueryResultBaseItemDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<QueryResultBaseItemDto>> GetLivetvRecordingsGroupsAsyncWithHttpInfo ();
        /// <summary>
        /// Gets live tv recordings
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of QueryResultBaseItemDto</returns>
        System.Threading.Tasks.Task<QueryResultBaseItemDto> GetLivetvRecordingsSeriesAsync ();

        /// <summary>
        /// Gets live tv recordings
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (QueryResultBaseItemDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<QueryResultBaseItemDto>> GetLivetvRecordingsSeriesAsyncWithHttpInfo ();
        /// <summary>
        /// Gets live tv series timers
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Optional. Sort by SortName or Priority (optional)</param>
        /// <param name="sortOrder">Optional. Sort in Ascending or Descending order (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <returns>Task of QueryResultLiveTvSeriesTimerInfoDto</returns>
        System.Threading.Tasks.Task<QueryResultLiveTvSeriesTimerInfoDto> GetLivetvSeriestimersAsync (string sortBy, SortOrder sortOrder, int? startIndex, int? limit);

        /// <summary>
        /// Gets live tv series timers
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Optional. Sort by SortName or Priority (optional)</param>
        /// <param name="sortOrder">Optional. Sort in Ascending or Descending order (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <returns>Task of ApiResponse (QueryResultLiveTvSeriesTimerInfoDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<QueryResultLiveTvSeriesTimerInfoDto>> GetLivetvSeriestimersAsyncWithHttpInfo (string sortBy, SortOrder sortOrder, int? startIndex, int? limit);
        /// <summary>
        /// Gets a live tv series timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>Task of LiveTvTimerInfoDto</returns>
        System.Threading.Tasks.Task<LiveTvTimerInfoDto> GetLivetvSeriestimersByIdAsync (string id);

        /// <summary>
        /// Gets a live tv series timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>Task of ApiResponse (LiveTvTimerInfoDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<LiveTvTimerInfoDto>> GetLivetvSeriestimersByIdAsyncWithHttpInfo (string id);
        /// <summary>
        /// Gets live tv timers
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">Optional filter by channel id. (optional)</param>
        /// <param name="seriesTimerId">Optional filter by timers belonging to a series timer (optional)</param>
        /// <returns>Task of QueryResultLiveTvTimerInfoDto</returns>
        System.Threading.Tasks.Task<QueryResultLiveTvTimerInfoDto> GetLivetvTimersAsync (string channelId, string seriesTimerId);

        /// <summary>
        /// Gets live tv timers
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">Optional filter by channel id. (optional)</param>
        /// <param name="seriesTimerId">Optional filter by timers belonging to a series timer (optional)</param>
        /// <returns>Task of ApiResponse (QueryResultLiveTvTimerInfoDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<QueryResultLiveTvTimerInfoDto>> GetLivetvTimersAsyncWithHttpInfo (string channelId, string seriesTimerId);
        /// <summary>
        /// Gets a live tv timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>Task of LiveTvTimerInfoDto</returns>
        System.Threading.Tasks.Task<LiveTvTimerInfoDto> GetLivetvTimersByIdAsync (string id);

        /// <summary>
        /// Gets a live tv timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>Task of ApiResponse (LiveTvTimerInfoDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<LiveTvTimerInfoDto>> GetLivetvTimersByIdAsyncWithHttpInfo (string id);
        /// <summary>
        /// Gets default values for a new timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="programId">Optional, to attach default values based on a program. (optional)</param>
        /// <returns>Task of LiveTvSeriesTimerInfoDto</returns>
        System.Threading.Tasks.Task<LiveTvSeriesTimerInfoDto> GetLivetvTimersDefaultsAsync (string programId);

        /// <summary>
        /// Gets default values for a new timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="programId">Optional, to attach default values based on a program. (optional)</param>
        /// <returns>Task of ApiResponse (LiveTvSeriesTimerInfoDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<LiveTvSeriesTimerInfoDto>> GetLivetvTimersDefaultsAsyncWithHttpInfo (string programId);
        /// <summary>
        /// Gets tuner hosts
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of List&lt;LiveTvTunerHostInfo&gt;</returns>
        System.Threading.Tasks.Task<List<LiveTvTunerHostInfo>> GetLivetvTunerhostsAsync ();

        /// <summary>
        /// Gets tuner hosts
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (List&lt;LiveTvTunerHostInfo&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<LiveTvTunerHostInfo>>> GetLivetvTunerhostsAsyncWithHttpInfo ();
        /// <summary>
        /// Gets tuner hosts
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">Type</param>
        /// <returns>Task of LiveTvTunerHostInfo</returns>
        System.Threading.Tasks.Task<LiveTvTunerHostInfo> GetLivetvTunerhostsDefaultByTypeAsync (string type);

        /// <summary>
        /// Gets tuner hosts
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">Type</param>
        /// <returns>Task of ApiResponse (LiveTvTunerHostInfo)</returns>
        System.Threading.Tasks.Task<ApiResponse<LiveTvTunerHostInfo>> GetLivetvTunerhostsDefaultByTypeAsyncWithHttpInfo (string type);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of List&lt;NameIdPair&gt;</returns>
        System.Threading.Tasks.Task<List<NameIdPair>> GetLivetvTunerhostsTypesAsync ();

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (List&lt;NameIdPair&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<NameIdPair>>> GetLivetvTunerhostsTypesAsyncWithHttpInfo ();
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of List&lt;LiveTvTunerHostInfo&gt;</returns>
        System.Threading.Tasks.Task<List<LiveTvTunerHostInfo>> GetLivetvTunersDiscvoverAsync ();

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (List&lt;LiveTvTunerHostInfo&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<LiveTvTunerHostInfo>>> GetLivetvTunersDiscvoverAsyncWithHttpInfo ();
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task HeadLivetvChannelmappingoptionsAsync (string providerId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> HeadLivetvChannelmappingoptionsAsyncWithHttpInfo (string providerId);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task HeadLivetvChannelmappingsAsync (string providerId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> HeadLivetvChannelmappingsAsyncWithHttpInfo (string providerId);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task PostLivetvChannelmappingoptionsAsync (string providerId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> PostLivetvChannelmappingoptionsAsyncWithHttpInfo (string providerId);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelMapping</param>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task PostLivetvChannelmappingsAsync (LiveTVApiSetChannelMapping body, string providerId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelMapping</param>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> PostLivetvChannelmappingsAsyncWithHttpInfo (LiveTVApiSetChannelMapping body, string providerId);
        /// <summary>
        /// Adds a listing provider
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">ListingsProviderInfo: </param>
        /// <returns>Task of LiveTvListingsProviderInfo</returns>
        System.Threading.Tasks.Task<LiveTvListingsProviderInfo> PostLivetvListingprovidersAsync (LiveTvListingsProviderInfo body);

        /// <summary>
        /// Adds a listing provider
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">ListingsProviderInfo: </param>
        /// <returns>Task of ApiResponse (LiveTvListingsProviderInfo)</returns>
        System.Threading.Tasks.Task<ApiResponse<LiveTvListingsProviderInfo>> PostLivetvListingprovidersAsyncWithHttpInfo (LiveTvListingsProviderInfo body);
        /// <summary>
        /// Deletes a listing provider
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Provider id (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task PostLivetvListingprovidersDeleteAsync (string id);

        /// <summary>
        /// Deletes a listing provider
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Provider id (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> PostLivetvListingprovidersDeleteAsyncWithHttpInfo (string id);
        /// <summary>
        /// Sets a channel disabled or not
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelDisabled</param>
        /// <param name="id"></param>
        /// <returns>Task of QueryResultEmbyLiveTVChannelManagementInfo</returns>
        System.Threading.Tasks.Task<QueryResultEmbyLiveTVChannelManagementInfo> PostLivetvManageChannelsByIdDisabledAsync (LiveTVApiSetChannelDisabled body, string id);

        /// <summary>
        /// Sets a channel disabled or not
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelDisabled</param>
        /// <param name="id"></param>
        /// <returns>Task of ApiResponse (QueryResultEmbyLiveTVChannelManagementInfo)</returns>
        System.Threading.Tasks.Task<ApiResponse<QueryResultEmbyLiveTVChannelManagementInfo>> PostLivetvManageChannelsByIdDisabledAsyncWithHttpInfo (LiveTVApiSetChannelDisabled body, string id);
        /// <summary>
        /// Sets a channel sort index
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelSortIndex</param>
        /// <param name="id"></param>
        /// <returns>Task of QueryResultEmbyLiveTVChannelManagementInfo</returns>
        System.Threading.Tasks.Task<QueryResultEmbyLiveTVChannelManagementInfo> PostLivetvManageChannelsByIdSortindexAsync (LiveTVApiSetChannelSortIndex body, string id);

        /// <summary>
        /// Sets a channel sort index
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelSortIndex</param>
        /// <param name="id"></param>
        /// <returns>Task of ApiResponse (QueryResultEmbyLiveTVChannelManagementInfo)</returns>
        System.Threading.Tasks.Task<ApiResponse<QueryResultEmbyLiveTVChannelManagementInfo>> PostLivetvManageChannelsByIdSortindexAsyncWithHttpInfo (LiveTVApiSetChannelSortIndex body, string id);
        /// <summary>
        /// Gets available live tv epgs..
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">GetPrograms</param>
        /// <param name="channelIds">The channels to return guide information for. (optional)</param>
        /// <param name="userId">Optional filter by user id. (optional)</param>
        /// <param name="hasAired">Optional. Filter by programs that have completed airing, or not. (optional)</param>
        /// <param name="minStartDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxStartDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minEndDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxEndDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <returns>Task of QueryResultBaseItemDto</returns>
        System.Threading.Tasks.Task<QueryResultBaseItemDto> PostLivetvProgramsAsync (LiveTVApiGetPrograms body, string channelIds, string userId, bool? hasAired, string minStartDate, string maxStartDate, string minEndDate, string maxEndDate, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, int? startIndex, int? limit, string sortBy, string sortOrder, string genreIds, bool? enableImages, int? imageTypeLimit, string enableImageTypes, bool? enableUserData, string fields);

        /// <summary>
        /// Gets available live tv epgs..
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">GetPrograms</param>
        /// <param name="channelIds">The channels to return guide information for. (optional)</param>
        /// <param name="userId">Optional filter by user id. (optional)</param>
        /// <param name="hasAired">Optional. Filter by programs that have completed airing, or not. (optional)</param>
        /// <param name="minStartDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxStartDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minEndDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxEndDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <returns>Task of ApiResponse (QueryResultBaseItemDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<QueryResultBaseItemDto>> PostLivetvProgramsAsyncWithHttpInfo (LiveTVApiGetPrograms body, string channelIds, string userId, bool? hasAired, string minStartDate, string maxStartDate, string minEndDate, string maxEndDate, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, int? startIndex, int? limit, string sortBy, string sortOrder, string genreIds, bool? enableImages, int? imageTypeLimit, string enableImageTypes, bool? enableUserData, string fields);
        /// <summary>
        /// Deletes a live tv recording
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Recording Id</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task PostLivetvRecordingsByIdDeleteAsync (string id);

        /// <summary>
        /// Deletes a live tv recording
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Recording Id</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> PostLivetvRecordingsByIdDeleteAsyncWithHttpInfo (string id);
        /// <summary>
        /// Creates a live tv series timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SeriesTimerInfo: </param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task PostLivetvSeriestimersAsync (LiveTvSeriesTimerInfo body);

        /// <summary>
        /// Creates a live tv series timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SeriesTimerInfo: </param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> PostLivetvSeriestimersAsyncWithHttpInfo (LiveTvSeriesTimerInfo body);
        /// <summary>
        /// Updates a live tv series timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SeriesTimerInfo: </param>
        /// <param name="id"></param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task PostLivetvSeriestimersByIdAsync (LiveTvSeriesTimerInfo body, string id);

        /// <summary>
        /// Updates a live tv series timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SeriesTimerInfo: </param>
        /// <param name="id"></param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> PostLivetvSeriestimersByIdAsyncWithHttpInfo (LiveTvSeriesTimerInfo body, string id);
        /// <summary>
        /// Cancels a live tv series timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task PostLivetvSeriestimersByIdDeleteAsync (string id);

        /// <summary>
        /// Cancels a live tv series timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> PostLivetvSeriestimersByIdDeleteAsyncWithHttpInfo (string id);
        /// <summary>
        /// Creates a live tv timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">TimerInfoDto: </param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task PostLivetvTimersAsync (LiveTvTimerInfoDto body);

        /// <summary>
        /// Creates a live tv timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">TimerInfoDto: </param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> PostLivetvTimersAsyncWithHttpInfo (LiveTvTimerInfoDto body);
        /// <summary>
        /// Updates a live tv timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">TimerInfoDto: </param>
        /// <param name="id"></param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task PostLivetvTimersByIdAsync (LiveTvTimerInfoDto body, string id);

        /// <summary>
        /// Updates a live tv timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">TimerInfoDto: </param>
        /// <param name="id"></param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> PostLivetvTimersByIdAsyncWithHttpInfo (LiveTvTimerInfoDto body, string id);
        /// <summary>
        /// Cancels a live tv timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task PostLivetvTimersByIdDeleteAsync (string id);

        /// <summary>
        /// Cancels a live tv timer
        /// </summary>
        /// <remarks>
        /// Requires authentication as user
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> PostLivetvTimersByIdDeleteAsyncWithHttpInfo (string id);
        /// <summary>
        /// Adds a tuner host
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">TunerHostInfo: </param>
        /// <returns>Task of LiveTvTunerHostInfo</returns>
        System.Threading.Tasks.Task<LiveTvTunerHostInfo> PostLivetvTunerhostsAsync (LiveTvTunerHostInfo body);

        /// <summary>
        /// Adds a tuner host
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">TunerHostInfo: </param>
        /// <returns>Task of ApiResponse (LiveTvTunerHostInfo)</returns>
        System.Threading.Tasks.Task<ApiResponse<LiveTvTunerHostInfo>> PostLivetvTunerhostsAsyncWithHttpInfo (LiveTvTunerHostInfo body);
        /// <summary>
        /// Deletes a tuner host
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Tuner host id (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task PostLivetvTunerhostsDeleteAsync (string id);

        /// <summary>
        /// Deletes a tuner host
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Tuner host id (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> PostLivetvTunerhostsDeleteAsyncWithHttpInfo (string id);
        /// <summary>
        /// Resets a tv tuner
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Tuner Id</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task PostLivetvTunersByIdResetAsync (string id);

        /// <summary>
        /// Resets a tv tuner
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Tuner Id</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> PostLivetvTunersByIdResetAsyncWithHttpInfo (string id);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task PutLivetvChannelmappingoptionsAsync (string providerId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> PutLivetvChannelmappingoptionsAsyncWithHttpInfo (string providerId);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelMapping</param>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task PutLivetvChannelmappingsAsync (LiveTVApiSetChannelMapping body, string providerId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Requires authentication as administrator
        /// </remarks>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelMapping</param>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> PutLivetvChannelmappingsAsyncWithHttpInfo (LiveTVApiSetChannelMapping body, string providerId);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public partial class LiveTvServiceApi : ILiveTvServiceApi
    {
        private EmbyClient.Dotnet.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="LiveTvServiceApi"/> class.
        /// </summary>
        /// <returns></returns>
        public LiveTvServiceApi(String basePath)
        {
            this.Configuration = new EmbyClient.Dotnet.Client.Configuration { BasePath = basePath };

            ExceptionFactory = EmbyClient.Dotnet.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LiveTvServiceApi"/> class
        /// </summary>
        /// <returns></returns>
        public LiveTvServiceApi()
        {
            this.Configuration = EmbyClient.Dotnet.Client.Configuration.Default;

            ExceptionFactory = EmbyClient.Dotnet.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LiveTvServiceApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public LiveTvServiceApi(EmbyClient.Dotnet.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = EmbyClient.Dotnet.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = EmbyClient.Dotnet.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public EmbyClient.Dotnet.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public EmbyClient.Dotnet.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns></returns>
        public void DeleteLivetvChannelmappingoptions (string providerId)
        {
             DeleteLivetvChannelmappingoptionsWithHttpInfo(providerId);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteLivetvChannelmappingoptionsWithHttpInfo (string providerId)
        {
            // verify the required parameter 'providerId' is set
            if (providerId == null)
                throw new ApiException(400, "Missing required parameter 'providerId' when calling LiveTvServiceApi->DeleteLivetvChannelmappingoptions");

            var localVarPath = "/LiveTv/ChannelMappingOptions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (providerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ProviderId", providerId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteLivetvChannelmappingoptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteLivetvChannelmappingoptionsAsync (string providerId)
        {
             await DeleteLivetvChannelmappingoptionsAsyncWithHttpInfo(providerId);

        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteLivetvChannelmappingoptionsAsyncWithHttpInfo (string providerId)
        {
            // verify the required parameter 'providerId' is set
            if (providerId == null)
                throw new ApiException(400, "Missing required parameter 'providerId' when calling LiveTvServiceApi->DeleteLivetvChannelmappingoptions");

            var localVarPath = "/LiveTv/ChannelMappingOptions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (providerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ProviderId", providerId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteLivetvChannelmappingoptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns></returns>
        public void DeleteLivetvChannelmappings (string providerId)
        {
             DeleteLivetvChannelmappingsWithHttpInfo(providerId);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteLivetvChannelmappingsWithHttpInfo (string providerId)
        {
            // verify the required parameter 'providerId' is set
            if (providerId == null)
                throw new ApiException(400, "Missing required parameter 'providerId' when calling LiveTvServiceApi->DeleteLivetvChannelmappings");

            var localVarPath = "/LiveTv/ChannelMappings";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (providerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ProviderId", providerId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteLivetvChannelmappings", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteLivetvChannelmappingsAsync (string providerId)
        {
             await DeleteLivetvChannelmappingsAsyncWithHttpInfo(providerId);

        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteLivetvChannelmappingsAsyncWithHttpInfo (string providerId)
        {
            // verify the required parameter 'providerId' is set
            if (providerId == null)
                throw new ApiException(400, "Missing required parameter 'providerId' when calling LiveTvServiceApi->DeleteLivetvChannelmappings");

            var localVarPath = "/LiveTv/ChannelMappings";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (providerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ProviderId", providerId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteLivetvChannelmappings", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Deletes a listing provider Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Provider id (optional)</param>
        /// <returns></returns>
        public void DeleteLivetvListingproviders (string id)
        {
             DeleteLivetvListingprovidersWithHttpInfo(id);
        }

        /// <summary>
        /// Deletes a listing provider Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Provider id (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteLivetvListingprovidersWithHttpInfo (string id)
        {

            var localVarPath = "/LiveTv/ListingProviders";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Id", id)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteLivetvListingproviders", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Deletes a listing provider Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Provider id (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteLivetvListingprovidersAsync (string id)
        {
             await DeleteLivetvListingprovidersAsyncWithHttpInfo(id);

        }

        /// <summary>
        /// Deletes a listing provider Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Provider id (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteLivetvListingprovidersAsyncWithHttpInfo (string id)
        {

            var localVarPath = "/LiveTv/ListingProviders";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Id", id)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteLivetvListingproviders", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Deletes a live tv recording Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Recording Id</param>
        /// <returns></returns>
        public void DeleteLivetvRecordingsById (string id)
        {
             DeleteLivetvRecordingsByIdWithHttpInfo(id);
        }

        /// <summary>
        /// Deletes a live tv recording Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Recording Id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteLivetvRecordingsByIdWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->DeleteLivetvRecordingsById");

            var localVarPath = "/LiveTv/Recordings/{Id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteLivetvRecordingsById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Deletes a live tv recording Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Recording Id</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteLivetvRecordingsByIdAsync (string id)
        {
             await DeleteLivetvRecordingsByIdAsyncWithHttpInfo(id);

        }

        /// <summary>
        /// Deletes a live tv recording Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Recording Id</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteLivetvRecordingsByIdAsyncWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->DeleteLivetvRecordingsById");

            var localVarPath = "/LiveTv/Recordings/{Id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteLivetvRecordingsById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Cancels a live tv series timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns></returns>
        public void DeleteLivetvSeriestimersById (string id)
        {
             DeleteLivetvSeriestimersByIdWithHttpInfo(id);
        }

        /// <summary>
        /// Cancels a live tv series timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteLivetvSeriestimersByIdWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->DeleteLivetvSeriestimersById");

            var localVarPath = "/LiveTv/SeriesTimers/{Id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteLivetvSeriestimersById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Cancels a live tv series timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteLivetvSeriestimersByIdAsync (string id)
        {
             await DeleteLivetvSeriestimersByIdAsyncWithHttpInfo(id);

        }

        /// <summary>
        /// Cancels a live tv series timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteLivetvSeriestimersByIdAsyncWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->DeleteLivetvSeriestimersById");

            var localVarPath = "/LiveTv/SeriesTimers/{Id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteLivetvSeriestimersById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Cancels a live tv timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns></returns>
        public void DeleteLivetvTimersById (string id)
        {
             DeleteLivetvTimersByIdWithHttpInfo(id);
        }

        /// <summary>
        /// Cancels a live tv timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteLivetvTimersByIdWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->DeleteLivetvTimersById");

            var localVarPath = "/LiveTv/Timers/{Id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteLivetvTimersById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Cancels a live tv timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteLivetvTimersByIdAsync (string id)
        {
             await DeleteLivetvTimersByIdAsyncWithHttpInfo(id);

        }

        /// <summary>
        /// Cancels a live tv timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteLivetvTimersByIdAsyncWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->DeleteLivetvTimersById");

            var localVarPath = "/LiveTv/Timers/{Id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteLivetvTimersById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Deletes a tuner host Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Tuner host id (optional)</param>
        /// <returns></returns>
        public void DeleteLivetvTunerhosts (string id)
        {
             DeleteLivetvTunerhostsWithHttpInfo(id);
        }

        /// <summary>
        /// Deletes a tuner host Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Tuner host id (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteLivetvTunerhostsWithHttpInfo (string id)
        {

            var localVarPath = "/LiveTv/TunerHosts";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Id", id)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteLivetvTunerhosts", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Deletes a tuner host Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Tuner host id (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteLivetvTunerhostsAsync (string id)
        {
             await DeleteLivetvTunerhostsAsyncWithHttpInfo(id);

        }

        /// <summary>
        /// Deletes a tuner host Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Tuner host id (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteLivetvTunerhostsAsyncWithHttpInfo (string id)
        {

            var localVarPath = "/LiveTv/TunerHosts";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Id", id)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteLivetvTunerhosts", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns></returns>
        public void GetLivetvChannelmappingoptions (string providerId)
        {
             GetLivetvChannelmappingoptionsWithHttpInfo(providerId);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> GetLivetvChannelmappingoptionsWithHttpInfo (string providerId)
        {
            // verify the required parameter 'providerId' is set
            if (providerId == null)
                throw new ApiException(400, "Missing required parameter 'providerId' when calling LiveTvServiceApi->GetLivetvChannelmappingoptions");

            var localVarPath = "/LiveTv/ChannelMappingOptions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (providerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ProviderId", providerId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvChannelmappingoptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task GetLivetvChannelmappingoptionsAsync (string providerId)
        {
             await GetLivetvChannelmappingoptionsAsyncWithHttpInfo(providerId);

        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> GetLivetvChannelmappingoptionsAsyncWithHttpInfo (string providerId)
        {
            // verify the required parameter 'providerId' is set
            if (providerId == null)
                throw new ApiException(400, "Missing required parameter 'providerId' when calling LiveTvServiceApi->GetLivetvChannelmappingoptions");

            var localVarPath = "/LiveTv/ChannelMappingOptions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (providerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ProviderId", providerId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvChannelmappingoptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns></returns>
        public void GetLivetvChannelmappings (string providerId)
        {
             GetLivetvChannelmappingsWithHttpInfo(providerId);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> GetLivetvChannelmappingsWithHttpInfo (string providerId)
        {
            // verify the required parameter 'providerId' is set
            if (providerId == null)
                throw new ApiException(400, "Missing required parameter 'providerId' when calling LiveTvServiceApi->GetLivetvChannelmappings");

            var localVarPath = "/LiveTv/ChannelMappings";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (providerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ProviderId", providerId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvChannelmappings", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task GetLivetvChannelmappingsAsync (string providerId)
        {
             await GetLivetvChannelmappingsAsyncWithHttpInfo(providerId);

        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> GetLivetvChannelmappingsAsyncWithHttpInfo (string providerId)
        {
            // verify the required parameter 'providerId' is set
            if (providerId == null)
                throw new ApiException(400, "Missing required parameter 'providerId' when calling LiveTvServiceApi->GetLivetvChannelmappings");

            var localVarPath = "/LiveTv/ChannelMappings";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (providerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ProviderId", providerId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvChannelmappings", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Gets available live tv channels. Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">Optional filter by channel type. (optional)</param>
        /// <param name="isLiked">Filter by channels that are liked, or not. (optional)</param>
        /// <param name="isDisliked">Filter by channels that are disliked, or not. (optional)</param>
        /// <param name="enableFavoriteSorting">Incorporate favorite and like status into channel sorting. (optional)</param>
        /// <param name="addCurrentProgram">Optional. Adds current program info to each channel (optional)</param>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>QueryResultBaseItemDto</returns>
        public QueryResultBaseItemDto GetLivetvChannels (LiveTvChannelType type, bool? isLiked, bool? isDisliked, bool? enableFavoriteSorting, bool? addCurrentProgram, string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan)
        {
             ApiResponse<QueryResultBaseItemDto> localVarResponse = GetLivetvChannelsWithHttpInfo(type, isLiked, isDisliked, enableFavoriteSorting, addCurrentProgram, artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, artistStartsWithOrGreater, albumArtistStartsWithOrGreater, nameStartsWith, nameLessThan);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets available live tv channels. Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">Optional filter by channel type. (optional)</param>
        /// <param name="isLiked">Filter by channels that are liked, or not. (optional)</param>
        /// <param name="isDisliked">Filter by channels that are disliked, or not. (optional)</param>
        /// <param name="enableFavoriteSorting">Incorporate favorite and like status into channel sorting. (optional)</param>
        /// <param name="addCurrentProgram">Optional. Adds current program info to each channel (optional)</param>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>ApiResponse of QueryResultBaseItemDto</returns>
        public ApiResponse< QueryResultBaseItemDto > GetLivetvChannelsWithHttpInfo (LiveTvChannelType type, bool? isLiked, bool? isDisliked, bool? enableFavoriteSorting, bool? addCurrentProgram, string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan)
        {

            var localVarPath = "/LiveTv/Channels";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (type != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Type", type)); // query parameter
            if (isLiked != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsLiked", isLiked)); // query parameter
            if (isDisliked != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsDisliked", isDisliked)); // query parameter
            if (enableFavoriteSorting != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableFavoriteSorting", enableFavoriteSorting)); // query parameter
            if (addCurrentProgram != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AddCurrentProgram", addCurrentProgram)); // query parameter
            if (artistType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ArtistType", artistType)); // query parameter
            if (maxOfficialRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxOfficialRating", maxOfficialRating)); // query parameter
            if (hasThemeSong != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasThemeSong", hasThemeSong)); // query parameter
            if (hasThemeVideo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasThemeVideo", hasThemeVideo)); // query parameter
            if (hasSubtitles != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasSubtitles", hasSubtitles)); // query parameter
            if (hasSpecialFeature != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasSpecialFeature", hasSpecialFeature)); // query parameter
            if (hasTrailer != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasTrailer", hasTrailer)); // query parameter
            if (adjacentTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AdjacentTo", adjacentTo)); // query parameter
            if (minIndexNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinIndexNumber", minIndexNumber)); // query parameter
            if (minPlayers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinPlayers", minPlayers)); // query parameter
            if (maxPlayers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxPlayers", maxPlayers)); // query parameter
            if (parentIndexNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ParentIndexNumber", parentIndexNumber)); // query parameter
            if (hasParentalRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasParentalRating", hasParentalRating)); // query parameter
            if (isHD != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsHD", isHD)); // query parameter
            if (locationTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "LocationTypes", locationTypes)); // query parameter
            if (excludeLocationTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ExcludeLocationTypes", excludeLocationTypes)); // query parameter
            if (isMissing != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsMissing", isMissing)); // query parameter
            if (isUnaired != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsUnaired", isUnaired)); // query parameter
            if (minCommunityRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinCommunityRating", minCommunityRating)); // query parameter
            if (minCriticRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinCriticRating", minCriticRating)); // query parameter
            if (airedDuringSeason != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AiredDuringSeason", airedDuringSeason)); // query parameter
            if (minPremiereDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinPremiereDate", minPremiereDate)); // query parameter
            if (minDateLastSaved != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinDateLastSaved", minDateLastSaved)); // query parameter
            if (minDateLastSavedForUser != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinDateLastSavedForUser", minDateLastSavedForUser)); // query parameter
            if (maxPremiereDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxPremiereDate", maxPremiereDate)); // query parameter
            if (hasOverview != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasOverview", hasOverview)); // query parameter
            if (hasImdbId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasImdbId", hasImdbId)); // query parameter
            if (hasTmdbId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasTmdbId", hasTmdbId)); // query parameter
            if (hasTvdbId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasTvdbId", hasTvdbId)); // query parameter
            if (excludeItemIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ExcludeItemIds", excludeItemIds)); // query parameter
            if (startIndex != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StartIndex", startIndex)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Limit", limit)); // query parameter
            if (recursive != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Recursive", recursive)); // query parameter
            if (searchTerm != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SearchTerm", searchTerm)); // query parameter
            if (sortOrder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortOrder", sortOrder)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ParentId", parentId)); // query parameter
            if (fields != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Fields", fields)); // query parameter
            if (excludeItemTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ExcludeItemTypes", excludeItemTypes)); // query parameter
            if (includeItemTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IncludeItemTypes", includeItemTypes)); // query parameter
            if (anyProviderIdEquals != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AnyProviderIdEquals", anyProviderIdEquals)); // query parameter
            if (filters != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Filters", filters)); // query parameter
            if (isFavorite != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsFavorite", isFavorite)); // query parameter
            if (isMovie != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsMovie", isMovie)); // query parameter
            if (isSeries != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSeries", isSeries)); // query parameter
            if (isNews != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsNews", isNews)); // query parameter
            if (isKids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsKids", isKids)); // query parameter
            if (isSports != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSports", isSports)); // query parameter
            if (mediaTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MediaTypes", mediaTypes)); // query parameter
            if (imageTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ImageTypes", imageTypes)); // query parameter
            if (sortBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortBy", sortBy)); // query parameter
            if (isPlayed != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsPlayed", isPlayed)); // query parameter
            if (genres != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Genres", genres)); // query parameter
            if (officialRatings != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "OfficialRatings", officialRatings)); // query parameter
            if (tags != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Tags", tags)); // query parameter
            if (years != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Years", years)); // query parameter
            if (enableImages != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImages", enableImages)); // query parameter
            if (enableUserData != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableUserData", enableUserData)); // query parameter
            if (imageTypeLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ImageTypeLimit", imageTypeLimit)); // query parameter
            if (enableImageTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImageTypes", enableImageTypes)); // query parameter
            if (person != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Person", person)); // query parameter
            if (personIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "PersonIds", personIds)); // query parameter
            if (personTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "PersonTypes", personTypes)); // query parameter
            if (studios != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Studios", studios)); // query parameter
            if (studioIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StudioIds", studioIds)); // query parameter
            if (artists != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Artists", artists)); // query parameter
            if (artistIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ArtistIds", artistIds)); // query parameter
            if (albums != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Albums", albums)); // query parameter
            if (ids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Ids", ids)); // query parameter
            if (videoTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "VideoTypes", videoTypes)); // query parameter
            if (containers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Containers", containers)); // query parameter
            if (audioCodecs != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AudioCodecs", audioCodecs)); // query parameter
            if (videoCodecs != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "VideoCodecs", videoCodecs)); // query parameter
            if (subtitleCodecs != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SubtitleCodecs", subtitleCodecs)); // query parameter
            if (path != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Path", path)); // query parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "UserId", userId)); // query parameter
            if (minOfficialRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinOfficialRating", minOfficialRating)); // query parameter
            if (isLocked != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsLocked", isLocked)); // query parameter
            if (isPlaceHolder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsPlaceHolder", isPlaceHolder)); // query parameter
            if (hasOfficialRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasOfficialRating", hasOfficialRating)); // query parameter
            if (groupItemsIntoCollections != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "GroupItemsIntoCollections", groupItemsIntoCollections)); // query parameter
            if (is3D != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Is3D", is3D)); // query parameter
            if (seriesStatus != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SeriesStatus", seriesStatus)); // query parameter
            if (nameStartsWithOrGreater != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "NameStartsWithOrGreater", nameStartsWithOrGreater)); // query parameter
            if (artistStartsWithOrGreater != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ArtistStartsWithOrGreater", artistStartsWithOrGreater)); // query parameter
            if (albumArtistStartsWithOrGreater != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AlbumArtistStartsWithOrGreater", albumArtistStartsWithOrGreater)); // query parameter
            if (nameStartsWith != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "NameStartsWith", nameStartsWith)); // query parameter
            if (nameLessThan != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "NameLessThan", nameLessThan)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvChannels", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultBaseItemDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultBaseItemDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultBaseItemDto)));
        }

        /// <summary>
        /// Gets available live tv channels. Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">Optional filter by channel type. (optional)</param>
        /// <param name="isLiked">Filter by channels that are liked, or not. (optional)</param>
        /// <param name="isDisliked">Filter by channels that are disliked, or not. (optional)</param>
        /// <param name="enableFavoriteSorting">Incorporate favorite and like status into channel sorting. (optional)</param>
        /// <param name="addCurrentProgram">Optional. Adds current program info to each channel (optional)</param>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>Task of QueryResultBaseItemDto</returns>
        public async System.Threading.Tasks.Task<QueryResultBaseItemDto> GetLivetvChannelsAsync (LiveTvChannelType type, bool? isLiked, bool? isDisliked, bool? enableFavoriteSorting, bool? addCurrentProgram, string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan)
        {
             ApiResponse<QueryResultBaseItemDto> localVarResponse = await GetLivetvChannelsAsyncWithHttpInfo(type, isLiked, isDisliked, enableFavoriteSorting, addCurrentProgram, artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, artistStartsWithOrGreater, albumArtistStartsWithOrGreater, nameStartsWith, nameLessThan);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets available live tv channels. Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">Optional filter by channel type. (optional)</param>
        /// <param name="isLiked">Filter by channels that are liked, or not. (optional)</param>
        /// <param name="isDisliked">Filter by channels that are disliked, or not. (optional)</param>
        /// <param name="enableFavoriteSorting">Incorporate favorite and like status into channel sorting. (optional)</param>
        /// <param name="addCurrentProgram">Optional. Adds current program info to each channel (optional)</param>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>Task of ApiResponse (QueryResultBaseItemDto)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<QueryResultBaseItemDto>> GetLivetvChannelsAsyncWithHttpInfo (LiveTvChannelType type, bool? isLiked, bool? isDisliked, bool? enableFavoriteSorting, bool? addCurrentProgram, string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan)
        {

            var localVarPath = "/LiveTv/Channels";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (type != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Type", type)); // query parameter
            if (isLiked != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsLiked", isLiked)); // query parameter
            if (isDisliked != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsDisliked", isDisliked)); // query parameter
            if (enableFavoriteSorting != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableFavoriteSorting", enableFavoriteSorting)); // query parameter
            if (addCurrentProgram != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AddCurrentProgram", addCurrentProgram)); // query parameter
            if (artistType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ArtistType", artistType)); // query parameter
            if (maxOfficialRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxOfficialRating", maxOfficialRating)); // query parameter
            if (hasThemeSong != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasThemeSong", hasThemeSong)); // query parameter
            if (hasThemeVideo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasThemeVideo", hasThemeVideo)); // query parameter
            if (hasSubtitles != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasSubtitles", hasSubtitles)); // query parameter
            if (hasSpecialFeature != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasSpecialFeature", hasSpecialFeature)); // query parameter
            if (hasTrailer != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasTrailer", hasTrailer)); // query parameter
            if (adjacentTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AdjacentTo", adjacentTo)); // query parameter
            if (minIndexNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinIndexNumber", minIndexNumber)); // query parameter
            if (minPlayers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinPlayers", minPlayers)); // query parameter
            if (maxPlayers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxPlayers", maxPlayers)); // query parameter
            if (parentIndexNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ParentIndexNumber", parentIndexNumber)); // query parameter
            if (hasParentalRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasParentalRating", hasParentalRating)); // query parameter
            if (isHD != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsHD", isHD)); // query parameter
            if (locationTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "LocationTypes", locationTypes)); // query parameter
            if (excludeLocationTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ExcludeLocationTypes", excludeLocationTypes)); // query parameter
            if (isMissing != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsMissing", isMissing)); // query parameter
            if (isUnaired != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsUnaired", isUnaired)); // query parameter
            if (minCommunityRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinCommunityRating", minCommunityRating)); // query parameter
            if (minCriticRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinCriticRating", minCriticRating)); // query parameter
            if (airedDuringSeason != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AiredDuringSeason", airedDuringSeason)); // query parameter
            if (minPremiereDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinPremiereDate", minPremiereDate)); // query parameter
            if (minDateLastSaved != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinDateLastSaved", minDateLastSaved)); // query parameter
            if (minDateLastSavedForUser != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinDateLastSavedForUser", minDateLastSavedForUser)); // query parameter
            if (maxPremiereDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxPremiereDate", maxPremiereDate)); // query parameter
            if (hasOverview != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasOverview", hasOverview)); // query parameter
            if (hasImdbId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasImdbId", hasImdbId)); // query parameter
            if (hasTmdbId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasTmdbId", hasTmdbId)); // query parameter
            if (hasTvdbId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasTvdbId", hasTvdbId)); // query parameter
            if (excludeItemIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ExcludeItemIds", excludeItemIds)); // query parameter
            if (startIndex != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StartIndex", startIndex)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Limit", limit)); // query parameter
            if (recursive != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Recursive", recursive)); // query parameter
            if (searchTerm != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SearchTerm", searchTerm)); // query parameter
            if (sortOrder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortOrder", sortOrder)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ParentId", parentId)); // query parameter
            if (fields != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Fields", fields)); // query parameter
            if (excludeItemTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ExcludeItemTypes", excludeItemTypes)); // query parameter
            if (includeItemTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IncludeItemTypes", includeItemTypes)); // query parameter
            if (anyProviderIdEquals != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AnyProviderIdEquals", anyProviderIdEquals)); // query parameter
            if (filters != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Filters", filters)); // query parameter
            if (isFavorite != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsFavorite", isFavorite)); // query parameter
            if (isMovie != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsMovie", isMovie)); // query parameter
            if (isSeries != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSeries", isSeries)); // query parameter
            if (isNews != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsNews", isNews)); // query parameter
            if (isKids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsKids", isKids)); // query parameter
            if (isSports != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSports", isSports)); // query parameter
            if (mediaTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MediaTypes", mediaTypes)); // query parameter
            if (imageTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ImageTypes", imageTypes)); // query parameter
            if (sortBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortBy", sortBy)); // query parameter
            if (isPlayed != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsPlayed", isPlayed)); // query parameter
            if (genres != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Genres", genres)); // query parameter
            if (officialRatings != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "OfficialRatings", officialRatings)); // query parameter
            if (tags != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Tags", tags)); // query parameter
            if (years != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Years", years)); // query parameter
            if (enableImages != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImages", enableImages)); // query parameter
            if (enableUserData != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableUserData", enableUserData)); // query parameter
            if (imageTypeLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ImageTypeLimit", imageTypeLimit)); // query parameter
            if (enableImageTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImageTypes", enableImageTypes)); // query parameter
            if (person != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Person", person)); // query parameter
            if (personIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "PersonIds", personIds)); // query parameter
            if (personTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "PersonTypes", personTypes)); // query parameter
            if (studios != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Studios", studios)); // query parameter
            if (studioIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StudioIds", studioIds)); // query parameter
            if (artists != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Artists", artists)); // query parameter
            if (artistIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ArtistIds", artistIds)); // query parameter
            if (albums != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Albums", albums)); // query parameter
            if (ids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Ids", ids)); // query parameter
            if (videoTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "VideoTypes", videoTypes)); // query parameter
            if (containers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Containers", containers)); // query parameter
            if (audioCodecs != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AudioCodecs", audioCodecs)); // query parameter
            if (videoCodecs != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "VideoCodecs", videoCodecs)); // query parameter
            if (subtitleCodecs != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SubtitleCodecs", subtitleCodecs)); // query parameter
            if (path != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Path", path)); // query parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "UserId", userId)); // query parameter
            if (minOfficialRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinOfficialRating", minOfficialRating)); // query parameter
            if (isLocked != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsLocked", isLocked)); // query parameter
            if (isPlaceHolder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsPlaceHolder", isPlaceHolder)); // query parameter
            if (hasOfficialRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasOfficialRating", hasOfficialRating)); // query parameter
            if (groupItemsIntoCollections != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "GroupItemsIntoCollections", groupItemsIntoCollections)); // query parameter
            if (is3D != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Is3D", is3D)); // query parameter
            if (seriesStatus != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SeriesStatus", seriesStatus)); // query parameter
            if (nameStartsWithOrGreater != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "NameStartsWithOrGreater", nameStartsWithOrGreater)); // query parameter
            if (artistStartsWithOrGreater != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ArtistStartsWithOrGreater", artistStartsWithOrGreater)); // query parameter
            if (albumArtistStartsWithOrGreater != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AlbumArtistStartsWithOrGreater", albumArtistStartsWithOrGreater)); // query parameter
            if (nameStartsWith != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "NameStartsWith", nameStartsWith)); // query parameter
            if (nameLessThan != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "NameLessThan", nameLessThan)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvChannels", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultBaseItemDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultBaseItemDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultBaseItemDto)));
        }

        /// <summary>
        /// Gets a live tv channel Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Channel Id</param>
        /// <param name="userId">Optional attach user data. (optional)</param>
        /// <returns>BaseItemDto</returns>
        public BaseItemDto GetLivetvChannelsById (string id, string userId)
        {
             ApiResponse<BaseItemDto> localVarResponse = GetLivetvChannelsByIdWithHttpInfo(id, userId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a live tv channel Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Channel Id</param>
        /// <param name="userId">Optional attach user data. (optional)</param>
        /// <returns>ApiResponse of BaseItemDto</returns>
        public ApiResponse< BaseItemDto > GetLivetvChannelsByIdWithHttpInfo (string id, string userId)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->GetLivetvChannelsById");

            var localVarPath = "/LiveTv/Channels/{Id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "UserId", userId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvChannelsById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BaseItemDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (BaseItemDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BaseItemDto)));
        }

        /// <summary>
        /// Gets a live tv channel Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Channel Id</param>
        /// <param name="userId">Optional attach user data. (optional)</param>
        /// <returns>Task of BaseItemDto</returns>
        public async System.Threading.Tasks.Task<BaseItemDto> GetLivetvChannelsByIdAsync (string id, string userId)
        {
             ApiResponse<BaseItemDto> localVarResponse = await GetLivetvChannelsByIdAsyncWithHttpInfo(id, userId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets a live tv channel Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Channel Id</param>
        /// <param name="userId">Optional attach user data. (optional)</param>
        /// <returns>Task of ApiResponse (BaseItemDto)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BaseItemDto>> GetLivetvChannelsByIdAsyncWithHttpInfo (string id, string userId)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->GetLivetvChannelsById");

            var localVarPath = "/LiveTv/Channels/{Id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "UserId", userId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvChannelsById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BaseItemDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (BaseItemDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BaseItemDto)));
        }

        /// <summary>
        /// Gets live tv channel tags No authentication required
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>QueryResultBaseItemDto</returns>
        public QueryResultBaseItemDto GetLivetvChanneltags (string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan)
        {
             ApiResponse<QueryResultBaseItemDto> localVarResponse = GetLivetvChanneltagsWithHttpInfo(artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, artistStartsWithOrGreater, albumArtistStartsWithOrGreater, nameStartsWith, nameLessThan);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets live tv channel tags No authentication required
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>ApiResponse of QueryResultBaseItemDto</returns>
        public ApiResponse< QueryResultBaseItemDto > GetLivetvChanneltagsWithHttpInfo (string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan)
        {

            var localVarPath = "/LiveTv/ChannelTags";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (artistType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ArtistType", artistType)); // query parameter
            if (maxOfficialRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxOfficialRating", maxOfficialRating)); // query parameter
            if (hasThemeSong != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasThemeSong", hasThemeSong)); // query parameter
            if (hasThemeVideo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasThemeVideo", hasThemeVideo)); // query parameter
            if (hasSubtitles != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasSubtitles", hasSubtitles)); // query parameter
            if (hasSpecialFeature != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasSpecialFeature", hasSpecialFeature)); // query parameter
            if (hasTrailer != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasTrailer", hasTrailer)); // query parameter
            if (adjacentTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AdjacentTo", adjacentTo)); // query parameter
            if (minIndexNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinIndexNumber", minIndexNumber)); // query parameter
            if (minPlayers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinPlayers", minPlayers)); // query parameter
            if (maxPlayers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxPlayers", maxPlayers)); // query parameter
            if (parentIndexNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ParentIndexNumber", parentIndexNumber)); // query parameter
            if (hasParentalRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasParentalRating", hasParentalRating)); // query parameter
            if (isHD != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsHD", isHD)); // query parameter
            if (locationTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "LocationTypes", locationTypes)); // query parameter
            if (excludeLocationTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ExcludeLocationTypes", excludeLocationTypes)); // query parameter
            if (isMissing != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsMissing", isMissing)); // query parameter
            if (isUnaired != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsUnaired", isUnaired)); // query parameter
            if (minCommunityRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinCommunityRating", minCommunityRating)); // query parameter
            if (minCriticRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinCriticRating", minCriticRating)); // query parameter
            if (airedDuringSeason != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AiredDuringSeason", airedDuringSeason)); // query parameter
            if (minPremiereDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinPremiereDate", minPremiereDate)); // query parameter
            if (minDateLastSaved != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinDateLastSaved", minDateLastSaved)); // query parameter
            if (minDateLastSavedForUser != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinDateLastSavedForUser", minDateLastSavedForUser)); // query parameter
            if (maxPremiereDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxPremiereDate", maxPremiereDate)); // query parameter
            if (hasOverview != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasOverview", hasOverview)); // query parameter
            if (hasImdbId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasImdbId", hasImdbId)); // query parameter
            if (hasTmdbId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasTmdbId", hasTmdbId)); // query parameter
            if (hasTvdbId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasTvdbId", hasTvdbId)); // query parameter
            if (excludeItemIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ExcludeItemIds", excludeItemIds)); // query parameter
            if (startIndex != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StartIndex", startIndex)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Limit", limit)); // query parameter
            if (recursive != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Recursive", recursive)); // query parameter
            if (searchTerm != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SearchTerm", searchTerm)); // query parameter
            if (sortOrder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortOrder", sortOrder)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ParentId", parentId)); // query parameter
            if (fields != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Fields", fields)); // query parameter
            if (excludeItemTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ExcludeItemTypes", excludeItemTypes)); // query parameter
            if (includeItemTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IncludeItemTypes", includeItemTypes)); // query parameter
            if (anyProviderIdEquals != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AnyProviderIdEquals", anyProviderIdEquals)); // query parameter
            if (filters != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Filters", filters)); // query parameter
            if (isFavorite != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsFavorite", isFavorite)); // query parameter
            if (isMovie != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsMovie", isMovie)); // query parameter
            if (isSeries != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSeries", isSeries)); // query parameter
            if (isNews != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsNews", isNews)); // query parameter
            if (isKids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsKids", isKids)); // query parameter
            if (isSports != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSports", isSports)); // query parameter
            if (mediaTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MediaTypes", mediaTypes)); // query parameter
            if (imageTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ImageTypes", imageTypes)); // query parameter
            if (sortBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortBy", sortBy)); // query parameter
            if (isPlayed != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsPlayed", isPlayed)); // query parameter
            if (genres != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Genres", genres)); // query parameter
            if (officialRatings != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "OfficialRatings", officialRatings)); // query parameter
            if (tags != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Tags", tags)); // query parameter
            if (years != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Years", years)); // query parameter
            if (enableImages != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImages", enableImages)); // query parameter
            if (enableUserData != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableUserData", enableUserData)); // query parameter
            if (imageTypeLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ImageTypeLimit", imageTypeLimit)); // query parameter
            if (enableImageTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImageTypes", enableImageTypes)); // query parameter
            if (person != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Person", person)); // query parameter
            if (personIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "PersonIds", personIds)); // query parameter
            if (personTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "PersonTypes", personTypes)); // query parameter
            if (studios != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Studios", studios)); // query parameter
            if (studioIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StudioIds", studioIds)); // query parameter
            if (artists != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Artists", artists)); // query parameter
            if (artistIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ArtistIds", artistIds)); // query parameter
            if (albums != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Albums", albums)); // query parameter
            if (ids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Ids", ids)); // query parameter
            if (videoTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "VideoTypes", videoTypes)); // query parameter
            if (containers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Containers", containers)); // query parameter
            if (audioCodecs != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AudioCodecs", audioCodecs)); // query parameter
            if (videoCodecs != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "VideoCodecs", videoCodecs)); // query parameter
            if (subtitleCodecs != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SubtitleCodecs", subtitleCodecs)); // query parameter
            if (path != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Path", path)); // query parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "UserId", userId)); // query parameter
            if (minOfficialRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinOfficialRating", minOfficialRating)); // query parameter
            if (isLocked != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsLocked", isLocked)); // query parameter
            if (isPlaceHolder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsPlaceHolder", isPlaceHolder)); // query parameter
            if (hasOfficialRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasOfficialRating", hasOfficialRating)); // query parameter
            if (groupItemsIntoCollections != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "GroupItemsIntoCollections", groupItemsIntoCollections)); // query parameter
            if (is3D != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Is3D", is3D)); // query parameter
            if (seriesStatus != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SeriesStatus", seriesStatus)); // query parameter
            if (nameStartsWithOrGreater != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "NameStartsWithOrGreater", nameStartsWithOrGreater)); // query parameter
            if (artistStartsWithOrGreater != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ArtistStartsWithOrGreater", artistStartsWithOrGreater)); // query parameter
            if (albumArtistStartsWithOrGreater != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AlbumArtistStartsWithOrGreater", albumArtistStartsWithOrGreater)); // query parameter
            if (nameStartsWith != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "NameStartsWith", nameStartsWith)); // query parameter
            if (nameLessThan != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "NameLessThan", nameLessThan)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvChanneltags", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultBaseItemDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultBaseItemDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultBaseItemDto)));
        }

        /// <summary>
        /// Gets live tv channel tags No authentication required
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>Task of QueryResultBaseItemDto</returns>
        public async System.Threading.Tasks.Task<QueryResultBaseItemDto> GetLivetvChanneltagsAsync (string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan)
        {
             ApiResponse<QueryResultBaseItemDto> localVarResponse = await GetLivetvChanneltagsAsyncWithHttpInfo(artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, artistStartsWithOrGreater, albumArtistStartsWithOrGreater, nameStartsWith, nameLessThan);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets live tv channel tags No authentication required
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>Task of ApiResponse (QueryResultBaseItemDto)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<QueryResultBaseItemDto>> GetLivetvChanneltagsAsyncWithHttpInfo (string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan)
        {

            var localVarPath = "/LiveTv/ChannelTags";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (artistType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ArtistType", artistType)); // query parameter
            if (maxOfficialRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxOfficialRating", maxOfficialRating)); // query parameter
            if (hasThemeSong != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasThemeSong", hasThemeSong)); // query parameter
            if (hasThemeVideo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasThemeVideo", hasThemeVideo)); // query parameter
            if (hasSubtitles != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasSubtitles", hasSubtitles)); // query parameter
            if (hasSpecialFeature != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasSpecialFeature", hasSpecialFeature)); // query parameter
            if (hasTrailer != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasTrailer", hasTrailer)); // query parameter
            if (adjacentTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AdjacentTo", adjacentTo)); // query parameter
            if (minIndexNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinIndexNumber", minIndexNumber)); // query parameter
            if (minPlayers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinPlayers", minPlayers)); // query parameter
            if (maxPlayers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxPlayers", maxPlayers)); // query parameter
            if (parentIndexNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ParentIndexNumber", parentIndexNumber)); // query parameter
            if (hasParentalRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasParentalRating", hasParentalRating)); // query parameter
            if (isHD != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsHD", isHD)); // query parameter
            if (locationTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "LocationTypes", locationTypes)); // query parameter
            if (excludeLocationTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ExcludeLocationTypes", excludeLocationTypes)); // query parameter
            if (isMissing != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsMissing", isMissing)); // query parameter
            if (isUnaired != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsUnaired", isUnaired)); // query parameter
            if (minCommunityRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinCommunityRating", minCommunityRating)); // query parameter
            if (minCriticRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinCriticRating", minCriticRating)); // query parameter
            if (airedDuringSeason != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AiredDuringSeason", airedDuringSeason)); // query parameter
            if (minPremiereDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinPremiereDate", minPremiereDate)); // query parameter
            if (minDateLastSaved != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinDateLastSaved", minDateLastSaved)); // query parameter
            if (minDateLastSavedForUser != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinDateLastSavedForUser", minDateLastSavedForUser)); // query parameter
            if (maxPremiereDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxPremiereDate", maxPremiereDate)); // query parameter
            if (hasOverview != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasOverview", hasOverview)); // query parameter
            if (hasImdbId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasImdbId", hasImdbId)); // query parameter
            if (hasTmdbId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasTmdbId", hasTmdbId)); // query parameter
            if (hasTvdbId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasTvdbId", hasTvdbId)); // query parameter
            if (excludeItemIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ExcludeItemIds", excludeItemIds)); // query parameter
            if (startIndex != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StartIndex", startIndex)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Limit", limit)); // query parameter
            if (recursive != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Recursive", recursive)); // query parameter
            if (searchTerm != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SearchTerm", searchTerm)); // query parameter
            if (sortOrder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortOrder", sortOrder)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ParentId", parentId)); // query parameter
            if (fields != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Fields", fields)); // query parameter
            if (excludeItemTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ExcludeItemTypes", excludeItemTypes)); // query parameter
            if (includeItemTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IncludeItemTypes", includeItemTypes)); // query parameter
            if (anyProviderIdEquals != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AnyProviderIdEquals", anyProviderIdEquals)); // query parameter
            if (filters != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Filters", filters)); // query parameter
            if (isFavorite != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsFavorite", isFavorite)); // query parameter
            if (isMovie != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsMovie", isMovie)); // query parameter
            if (isSeries != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSeries", isSeries)); // query parameter
            if (isNews != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsNews", isNews)); // query parameter
            if (isKids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsKids", isKids)); // query parameter
            if (isSports != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSports", isSports)); // query parameter
            if (mediaTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MediaTypes", mediaTypes)); // query parameter
            if (imageTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ImageTypes", imageTypes)); // query parameter
            if (sortBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortBy", sortBy)); // query parameter
            if (isPlayed != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsPlayed", isPlayed)); // query parameter
            if (genres != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Genres", genres)); // query parameter
            if (officialRatings != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "OfficialRatings", officialRatings)); // query parameter
            if (tags != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Tags", tags)); // query parameter
            if (years != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Years", years)); // query parameter
            if (enableImages != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImages", enableImages)); // query parameter
            if (enableUserData != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableUserData", enableUserData)); // query parameter
            if (imageTypeLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ImageTypeLimit", imageTypeLimit)); // query parameter
            if (enableImageTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImageTypes", enableImageTypes)); // query parameter
            if (person != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Person", person)); // query parameter
            if (personIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "PersonIds", personIds)); // query parameter
            if (personTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "PersonTypes", personTypes)); // query parameter
            if (studios != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Studios", studios)); // query parameter
            if (studioIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StudioIds", studioIds)); // query parameter
            if (artists != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Artists", artists)); // query parameter
            if (artistIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ArtistIds", artistIds)); // query parameter
            if (albums != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Albums", albums)); // query parameter
            if (ids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Ids", ids)); // query parameter
            if (videoTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "VideoTypes", videoTypes)); // query parameter
            if (containers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Containers", containers)); // query parameter
            if (audioCodecs != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AudioCodecs", audioCodecs)); // query parameter
            if (videoCodecs != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "VideoCodecs", videoCodecs)); // query parameter
            if (subtitleCodecs != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SubtitleCodecs", subtitleCodecs)); // query parameter
            if (path != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Path", path)); // query parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "UserId", userId)); // query parameter
            if (minOfficialRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinOfficialRating", minOfficialRating)); // query parameter
            if (isLocked != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsLocked", isLocked)); // query parameter
            if (isPlaceHolder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsPlaceHolder", isPlaceHolder)); // query parameter
            if (hasOfficialRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasOfficialRating", hasOfficialRating)); // query parameter
            if (groupItemsIntoCollections != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "GroupItemsIntoCollections", groupItemsIntoCollections)); // query parameter
            if (is3D != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Is3D", is3D)); // query parameter
            if (seriesStatus != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SeriesStatus", seriesStatus)); // query parameter
            if (nameStartsWithOrGreater != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "NameStartsWithOrGreater", nameStartsWithOrGreater)); // query parameter
            if (artistStartsWithOrGreater != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ArtistStartsWithOrGreater", artistStartsWithOrGreater)); // query parameter
            if (albumArtistStartsWithOrGreater != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AlbumArtistStartsWithOrGreater", albumArtistStartsWithOrGreater)); // query parameter
            if (nameStartsWith != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "NameStartsWith", nameStartsWith)); // query parameter
            if (nameLessThan != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "NameLessThan", nameLessThan)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvChanneltags", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultBaseItemDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultBaseItemDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultBaseItemDto)));
        }

        /// <summary>
        /// Gets live tv channel tag prefixes No authentication required
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>List&lt;LiveTVApiTagItem&gt;</returns>
        public List<LiveTVApiTagItem> GetLivetvChanneltagsPrefixes (string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan)
        {
             ApiResponse<List<LiveTVApiTagItem>> localVarResponse = GetLivetvChanneltagsPrefixesWithHttpInfo(artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, artistStartsWithOrGreater, albumArtistStartsWithOrGreater, nameStartsWith, nameLessThan);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets live tv channel tag prefixes No authentication required
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>ApiResponse of List&lt;LiveTVApiTagItem&gt;</returns>
        public ApiResponse< List<LiveTVApiTagItem> > GetLivetvChanneltagsPrefixesWithHttpInfo (string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan)
        {

            var localVarPath = "/LiveTv/ChannelTags/Prefixes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (artistType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ArtistType", artistType)); // query parameter
            if (maxOfficialRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxOfficialRating", maxOfficialRating)); // query parameter
            if (hasThemeSong != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasThemeSong", hasThemeSong)); // query parameter
            if (hasThemeVideo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasThemeVideo", hasThemeVideo)); // query parameter
            if (hasSubtitles != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasSubtitles", hasSubtitles)); // query parameter
            if (hasSpecialFeature != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasSpecialFeature", hasSpecialFeature)); // query parameter
            if (hasTrailer != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasTrailer", hasTrailer)); // query parameter
            if (adjacentTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AdjacentTo", adjacentTo)); // query parameter
            if (minIndexNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinIndexNumber", minIndexNumber)); // query parameter
            if (minPlayers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinPlayers", minPlayers)); // query parameter
            if (maxPlayers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxPlayers", maxPlayers)); // query parameter
            if (parentIndexNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ParentIndexNumber", parentIndexNumber)); // query parameter
            if (hasParentalRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasParentalRating", hasParentalRating)); // query parameter
            if (isHD != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsHD", isHD)); // query parameter
            if (locationTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "LocationTypes", locationTypes)); // query parameter
            if (excludeLocationTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ExcludeLocationTypes", excludeLocationTypes)); // query parameter
            if (isMissing != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsMissing", isMissing)); // query parameter
            if (isUnaired != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsUnaired", isUnaired)); // query parameter
            if (minCommunityRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinCommunityRating", minCommunityRating)); // query parameter
            if (minCriticRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinCriticRating", minCriticRating)); // query parameter
            if (airedDuringSeason != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AiredDuringSeason", airedDuringSeason)); // query parameter
            if (minPremiereDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinPremiereDate", minPremiereDate)); // query parameter
            if (minDateLastSaved != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinDateLastSaved", minDateLastSaved)); // query parameter
            if (minDateLastSavedForUser != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinDateLastSavedForUser", minDateLastSavedForUser)); // query parameter
            if (maxPremiereDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxPremiereDate", maxPremiereDate)); // query parameter
            if (hasOverview != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasOverview", hasOverview)); // query parameter
            if (hasImdbId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasImdbId", hasImdbId)); // query parameter
            if (hasTmdbId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasTmdbId", hasTmdbId)); // query parameter
            if (hasTvdbId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasTvdbId", hasTvdbId)); // query parameter
            if (excludeItemIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ExcludeItemIds", excludeItemIds)); // query parameter
            if (startIndex != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StartIndex", startIndex)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Limit", limit)); // query parameter
            if (recursive != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Recursive", recursive)); // query parameter
            if (searchTerm != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SearchTerm", searchTerm)); // query parameter
            if (sortOrder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortOrder", sortOrder)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ParentId", parentId)); // query parameter
            if (fields != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Fields", fields)); // query parameter
            if (excludeItemTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ExcludeItemTypes", excludeItemTypes)); // query parameter
            if (includeItemTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IncludeItemTypes", includeItemTypes)); // query parameter
            if (anyProviderIdEquals != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AnyProviderIdEquals", anyProviderIdEquals)); // query parameter
            if (filters != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Filters", filters)); // query parameter
            if (isFavorite != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsFavorite", isFavorite)); // query parameter
            if (isMovie != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsMovie", isMovie)); // query parameter
            if (isSeries != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSeries", isSeries)); // query parameter
            if (isNews != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsNews", isNews)); // query parameter
            if (isKids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsKids", isKids)); // query parameter
            if (isSports != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSports", isSports)); // query parameter
            if (mediaTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MediaTypes", mediaTypes)); // query parameter
            if (imageTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ImageTypes", imageTypes)); // query parameter
            if (sortBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortBy", sortBy)); // query parameter
            if (isPlayed != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsPlayed", isPlayed)); // query parameter
            if (genres != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Genres", genres)); // query parameter
            if (officialRatings != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "OfficialRatings", officialRatings)); // query parameter
            if (tags != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Tags", tags)); // query parameter
            if (years != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Years", years)); // query parameter
            if (enableImages != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImages", enableImages)); // query parameter
            if (enableUserData != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableUserData", enableUserData)); // query parameter
            if (imageTypeLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ImageTypeLimit", imageTypeLimit)); // query parameter
            if (enableImageTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImageTypes", enableImageTypes)); // query parameter
            if (person != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Person", person)); // query parameter
            if (personIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "PersonIds", personIds)); // query parameter
            if (personTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "PersonTypes", personTypes)); // query parameter
            if (studios != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Studios", studios)); // query parameter
            if (studioIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StudioIds", studioIds)); // query parameter
            if (artists != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Artists", artists)); // query parameter
            if (artistIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ArtistIds", artistIds)); // query parameter
            if (albums != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Albums", albums)); // query parameter
            if (ids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Ids", ids)); // query parameter
            if (videoTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "VideoTypes", videoTypes)); // query parameter
            if (containers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Containers", containers)); // query parameter
            if (audioCodecs != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AudioCodecs", audioCodecs)); // query parameter
            if (videoCodecs != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "VideoCodecs", videoCodecs)); // query parameter
            if (subtitleCodecs != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SubtitleCodecs", subtitleCodecs)); // query parameter
            if (path != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Path", path)); // query parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "UserId", userId)); // query parameter
            if (minOfficialRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinOfficialRating", minOfficialRating)); // query parameter
            if (isLocked != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsLocked", isLocked)); // query parameter
            if (isPlaceHolder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsPlaceHolder", isPlaceHolder)); // query parameter
            if (hasOfficialRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasOfficialRating", hasOfficialRating)); // query parameter
            if (groupItemsIntoCollections != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "GroupItemsIntoCollections", groupItemsIntoCollections)); // query parameter
            if (is3D != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Is3D", is3D)); // query parameter
            if (seriesStatus != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SeriesStatus", seriesStatus)); // query parameter
            if (nameStartsWithOrGreater != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "NameStartsWithOrGreater", nameStartsWithOrGreater)); // query parameter
            if (artistStartsWithOrGreater != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ArtistStartsWithOrGreater", artistStartsWithOrGreater)); // query parameter
            if (albumArtistStartsWithOrGreater != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AlbumArtistStartsWithOrGreater", albumArtistStartsWithOrGreater)); // query parameter
            if (nameStartsWith != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "NameStartsWith", nameStartsWith)); // query parameter
            if (nameLessThan != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "NameLessThan", nameLessThan)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvChanneltagsPrefixes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<LiveTVApiTagItem>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<LiveTVApiTagItem>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<LiveTVApiTagItem>)));
        }

        /// <summary>
        /// Gets live tv channel tag prefixes No authentication required
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>Task of List&lt;LiveTVApiTagItem&gt;</returns>
        public async System.Threading.Tasks.Task<List<LiveTVApiTagItem>> GetLivetvChanneltagsPrefixesAsync (string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan)
        {
             ApiResponse<List<LiveTVApiTagItem>> localVarResponse = await GetLivetvChanneltagsPrefixesAsyncWithHttpInfo(artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, artistStartsWithOrGreater, albumArtistStartsWithOrGreater, nameStartsWith, nameLessThan);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets live tv channel tag prefixes No authentication required
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;LiveTVApiTagItem&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<LiveTVApiTagItem>>> GetLivetvChanneltagsPrefixesAsyncWithHttpInfo (string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan)
        {

            var localVarPath = "/LiveTv/ChannelTags/Prefixes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (artistType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ArtistType", artistType)); // query parameter
            if (maxOfficialRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxOfficialRating", maxOfficialRating)); // query parameter
            if (hasThemeSong != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasThemeSong", hasThemeSong)); // query parameter
            if (hasThemeVideo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasThemeVideo", hasThemeVideo)); // query parameter
            if (hasSubtitles != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasSubtitles", hasSubtitles)); // query parameter
            if (hasSpecialFeature != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasSpecialFeature", hasSpecialFeature)); // query parameter
            if (hasTrailer != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasTrailer", hasTrailer)); // query parameter
            if (adjacentTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AdjacentTo", adjacentTo)); // query parameter
            if (minIndexNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinIndexNumber", minIndexNumber)); // query parameter
            if (minPlayers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinPlayers", minPlayers)); // query parameter
            if (maxPlayers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxPlayers", maxPlayers)); // query parameter
            if (parentIndexNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ParentIndexNumber", parentIndexNumber)); // query parameter
            if (hasParentalRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasParentalRating", hasParentalRating)); // query parameter
            if (isHD != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsHD", isHD)); // query parameter
            if (locationTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "LocationTypes", locationTypes)); // query parameter
            if (excludeLocationTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ExcludeLocationTypes", excludeLocationTypes)); // query parameter
            if (isMissing != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsMissing", isMissing)); // query parameter
            if (isUnaired != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsUnaired", isUnaired)); // query parameter
            if (minCommunityRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinCommunityRating", minCommunityRating)); // query parameter
            if (minCriticRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinCriticRating", minCriticRating)); // query parameter
            if (airedDuringSeason != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AiredDuringSeason", airedDuringSeason)); // query parameter
            if (minPremiereDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinPremiereDate", minPremiereDate)); // query parameter
            if (minDateLastSaved != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinDateLastSaved", minDateLastSaved)); // query parameter
            if (minDateLastSavedForUser != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinDateLastSavedForUser", minDateLastSavedForUser)); // query parameter
            if (maxPremiereDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxPremiereDate", maxPremiereDate)); // query parameter
            if (hasOverview != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasOverview", hasOverview)); // query parameter
            if (hasImdbId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasImdbId", hasImdbId)); // query parameter
            if (hasTmdbId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasTmdbId", hasTmdbId)); // query parameter
            if (hasTvdbId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasTvdbId", hasTvdbId)); // query parameter
            if (excludeItemIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ExcludeItemIds", excludeItemIds)); // query parameter
            if (startIndex != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StartIndex", startIndex)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Limit", limit)); // query parameter
            if (recursive != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Recursive", recursive)); // query parameter
            if (searchTerm != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SearchTerm", searchTerm)); // query parameter
            if (sortOrder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortOrder", sortOrder)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ParentId", parentId)); // query parameter
            if (fields != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Fields", fields)); // query parameter
            if (excludeItemTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ExcludeItemTypes", excludeItemTypes)); // query parameter
            if (includeItemTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IncludeItemTypes", includeItemTypes)); // query parameter
            if (anyProviderIdEquals != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AnyProviderIdEquals", anyProviderIdEquals)); // query parameter
            if (filters != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Filters", filters)); // query parameter
            if (isFavorite != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsFavorite", isFavorite)); // query parameter
            if (isMovie != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsMovie", isMovie)); // query parameter
            if (isSeries != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSeries", isSeries)); // query parameter
            if (isNews != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsNews", isNews)); // query parameter
            if (isKids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsKids", isKids)); // query parameter
            if (isSports != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSports", isSports)); // query parameter
            if (mediaTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MediaTypes", mediaTypes)); // query parameter
            if (imageTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ImageTypes", imageTypes)); // query parameter
            if (sortBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortBy", sortBy)); // query parameter
            if (isPlayed != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsPlayed", isPlayed)); // query parameter
            if (genres != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Genres", genres)); // query parameter
            if (officialRatings != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "OfficialRatings", officialRatings)); // query parameter
            if (tags != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Tags", tags)); // query parameter
            if (years != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Years", years)); // query parameter
            if (enableImages != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImages", enableImages)); // query parameter
            if (enableUserData != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableUserData", enableUserData)); // query parameter
            if (imageTypeLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ImageTypeLimit", imageTypeLimit)); // query parameter
            if (enableImageTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImageTypes", enableImageTypes)); // query parameter
            if (person != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Person", person)); // query parameter
            if (personIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "PersonIds", personIds)); // query parameter
            if (personTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "PersonTypes", personTypes)); // query parameter
            if (studios != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Studios", studios)); // query parameter
            if (studioIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StudioIds", studioIds)); // query parameter
            if (artists != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Artists", artists)); // query parameter
            if (artistIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ArtistIds", artistIds)); // query parameter
            if (albums != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Albums", albums)); // query parameter
            if (ids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Ids", ids)); // query parameter
            if (videoTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "VideoTypes", videoTypes)); // query parameter
            if (containers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Containers", containers)); // query parameter
            if (audioCodecs != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AudioCodecs", audioCodecs)); // query parameter
            if (videoCodecs != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "VideoCodecs", videoCodecs)); // query parameter
            if (subtitleCodecs != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SubtitleCodecs", subtitleCodecs)); // query parameter
            if (path != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Path", path)); // query parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "UserId", userId)); // query parameter
            if (minOfficialRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinOfficialRating", minOfficialRating)); // query parameter
            if (isLocked != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsLocked", isLocked)); // query parameter
            if (isPlaceHolder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsPlaceHolder", isPlaceHolder)); // query parameter
            if (hasOfficialRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasOfficialRating", hasOfficialRating)); // query parameter
            if (groupItemsIntoCollections != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "GroupItemsIntoCollections", groupItemsIntoCollections)); // query parameter
            if (is3D != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Is3D", is3D)); // query parameter
            if (seriesStatus != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SeriesStatus", seriesStatus)); // query parameter
            if (nameStartsWithOrGreater != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "NameStartsWithOrGreater", nameStartsWithOrGreater)); // query parameter
            if (artistStartsWithOrGreater != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ArtistStartsWithOrGreater", artistStartsWithOrGreater)); // query parameter
            if (albumArtistStartsWithOrGreater != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AlbumArtistStartsWithOrGreater", albumArtistStartsWithOrGreater)); // query parameter
            if (nameStartsWith != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "NameStartsWith", nameStartsWith)); // query parameter
            if (nameLessThan != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "NameLessThan", nameLessThan)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvChanneltagsPrefixes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<LiveTVApiTagItem>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<LiveTVApiTagItem>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<LiveTVApiTagItem>)));
        }

        /// <summary>
        /// Gets the epg. Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">Optional filter by channel type. (optional)</param>
        /// <param name="userId">Optional filter by user and attach user data. (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="minStartDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxStartDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minEndDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxEndDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="isFavorite">Filter by channels that are favorites, or not. (optional)</param>
        /// <param name="isLiked">Filter by channels that are liked, or not. (optional)</param>
        /// <param name="isDisliked">Filter by channels that are disliked, or not. (optional)</param>
        /// <param name="enableFavoriteSorting">Incorporate favorite and like status into channel sorting. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="addCurrentProgram">Optional. Adds current program info to each channel (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="channelIds">The channels to return guide information for. (optional)</param>
        /// <returns>QueryResultLiveTVApiEpgRow</returns>
        public QueryResultLiveTVApiEpgRow GetLivetvEPG (LiveTvChannelType type, string userId, string genreIds, string minStartDate, string maxStartDate, string minEndDate, string maxEndDate, int? startIndex, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, int? limit, bool? isFavorite, bool? isLiked, bool? isDisliked, bool? enableFavoriteSorting, bool? enableImages, int? imageTypeLimit, string enableImageTypes, string fields, bool? addCurrentProgram, bool? enableUserData, string channelIds)
        {
             ApiResponse<QueryResultLiveTVApiEpgRow> localVarResponse = GetLivetvEPGWithHttpInfo(type, userId, genreIds, minStartDate, maxStartDate, minEndDate, maxEndDate, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableFavoriteSorting, enableImages, imageTypeLimit, enableImageTypes, fields, addCurrentProgram, enableUserData, channelIds);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets the epg. Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">Optional filter by channel type. (optional)</param>
        /// <param name="userId">Optional filter by user and attach user data. (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="minStartDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxStartDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minEndDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxEndDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="isFavorite">Filter by channels that are favorites, or not. (optional)</param>
        /// <param name="isLiked">Filter by channels that are liked, or not. (optional)</param>
        /// <param name="isDisliked">Filter by channels that are disliked, or not. (optional)</param>
        /// <param name="enableFavoriteSorting">Incorporate favorite and like status into channel sorting. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="addCurrentProgram">Optional. Adds current program info to each channel (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="channelIds">The channels to return guide information for. (optional)</param>
        /// <returns>ApiResponse of QueryResultLiveTVApiEpgRow</returns>
        public ApiResponse< QueryResultLiveTVApiEpgRow > GetLivetvEPGWithHttpInfo (LiveTvChannelType type, string userId, string genreIds, string minStartDate, string maxStartDate, string minEndDate, string maxEndDate, int? startIndex, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, int? limit, bool? isFavorite, bool? isLiked, bool? isDisliked, bool? enableFavoriteSorting, bool? enableImages, int? imageTypeLimit, string enableImageTypes, string fields, bool? addCurrentProgram, bool? enableUserData, string channelIds)
        {

            var localVarPath = "/LiveTv/EPG";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (type != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Type", type)); // query parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "UserId", userId)); // query parameter
            if (genreIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "GenreIds", genreIds)); // query parameter
            if (minStartDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinStartDate", minStartDate)); // query parameter
            if (maxStartDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxStartDate", maxStartDate)); // query parameter
            if (minEndDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinEndDate", minEndDate)); // query parameter
            if (maxEndDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxEndDate", maxEndDate)); // query parameter
            if (startIndex != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StartIndex", startIndex)); // query parameter
            if (isMovie != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsMovie", isMovie)); // query parameter
            if (isSeries != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSeries", isSeries)); // query parameter
            if (isNews != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsNews", isNews)); // query parameter
            if (isKids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsKids", isKids)); // query parameter
            if (isSports != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSports", isSports)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Limit", limit)); // query parameter
            if (isFavorite != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsFavorite", isFavorite)); // query parameter
            if (isLiked != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsLiked", isLiked)); // query parameter
            if (isDisliked != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsDisliked", isDisliked)); // query parameter
            if (enableFavoriteSorting != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableFavoriteSorting", enableFavoriteSorting)); // query parameter
            if (enableImages != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImages", enableImages)); // query parameter
            if (imageTypeLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ImageTypeLimit", imageTypeLimit)); // query parameter
            if (enableImageTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImageTypes", enableImageTypes)); // query parameter
            if (fields != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Fields", fields)); // query parameter
            if (addCurrentProgram != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AddCurrentProgram", addCurrentProgram)); // query parameter
            if (enableUserData != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableUserData", enableUserData)); // query parameter
            if (channelIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ChannelIds", channelIds)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvEPG", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultLiveTVApiEpgRow>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultLiveTVApiEpgRow) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultLiveTVApiEpgRow)));
        }

        /// <summary>
        /// Gets the epg. Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">Optional filter by channel type. (optional)</param>
        /// <param name="userId">Optional filter by user and attach user data. (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="minStartDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxStartDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minEndDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxEndDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="isFavorite">Filter by channels that are favorites, or not. (optional)</param>
        /// <param name="isLiked">Filter by channels that are liked, or not. (optional)</param>
        /// <param name="isDisliked">Filter by channels that are disliked, or not. (optional)</param>
        /// <param name="enableFavoriteSorting">Incorporate favorite and like status into channel sorting. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="addCurrentProgram">Optional. Adds current program info to each channel (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="channelIds">The channels to return guide information for. (optional)</param>
        /// <returns>Task of QueryResultLiveTVApiEpgRow</returns>
        public async System.Threading.Tasks.Task<QueryResultLiveTVApiEpgRow> GetLivetvEPGAsync (LiveTvChannelType type, string userId, string genreIds, string minStartDate, string maxStartDate, string minEndDate, string maxEndDate, int? startIndex, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, int? limit, bool? isFavorite, bool? isLiked, bool? isDisliked, bool? enableFavoriteSorting, bool? enableImages, int? imageTypeLimit, string enableImageTypes, string fields, bool? addCurrentProgram, bool? enableUserData, string channelIds)
        {
             ApiResponse<QueryResultLiveTVApiEpgRow> localVarResponse = await GetLivetvEPGAsyncWithHttpInfo(type, userId, genreIds, minStartDate, maxStartDate, minEndDate, maxEndDate, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableFavoriteSorting, enableImages, imageTypeLimit, enableImageTypes, fields, addCurrentProgram, enableUserData, channelIds);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets the epg. Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">Optional filter by channel type. (optional)</param>
        /// <param name="userId">Optional filter by user and attach user data. (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="minStartDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxStartDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minEndDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxEndDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="isFavorite">Filter by channels that are favorites, or not. (optional)</param>
        /// <param name="isLiked">Filter by channels that are liked, or not. (optional)</param>
        /// <param name="isDisliked">Filter by channels that are disliked, or not. (optional)</param>
        /// <param name="enableFavoriteSorting">Incorporate favorite and like status into channel sorting. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="addCurrentProgram">Optional. Adds current program info to each channel (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="channelIds">The channels to return guide information for. (optional)</param>
        /// <returns>Task of ApiResponse (QueryResultLiveTVApiEpgRow)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<QueryResultLiveTVApiEpgRow>> GetLivetvEPGAsyncWithHttpInfo (LiveTvChannelType type, string userId, string genreIds, string minStartDate, string maxStartDate, string minEndDate, string maxEndDate, int? startIndex, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, int? limit, bool? isFavorite, bool? isLiked, bool? isDisliked, bool? enableFavoriteSorting, bool? enableImages, int? imageTypeLimit, string enableImageTypes, string fields, bool? addCurrentProgram, bool? enableUserData, string channelIds)
        {

            var localVarPath = "/LiveTv/EPG";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (type != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Type", type)); // query parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "UserId", userId)); // query parameter
            if (genreIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "GenreIds", genreIds)); // query parameter
            if (minStartDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinStartDate", minStartDate)); // query parameter
            if (maxStartDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxStartDate", maxStartDate)); // query parameter
            if (minEndDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinEndDate", minEndDate)); // query parameter
            if (maxEndDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxEndDate", maxEndDate)); // query parameter
            if (startIndex != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StartIndex", startIndex)); // query parameter
            if (isMovie != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsMovie", isMovie)); // query parameter
            if (isSeries != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSeries", isSeries)); // query parameter
            if (isNews != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsNews", isNews)); // query parameter
            if (isKids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsKids", isKids)); // query parameter
            if (isSports != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSports", isSports)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Limit", limit)); // query parameter
            if (isFavorite != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsFavorite", isFavorite)); // query parameter
            if (isLiked != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsLiked", isLiked)); // query parameter
            if (isDisliked != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsDisliked", isDisliked)); // query parameter
            if (enableFavoriteSorting != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableFavoriteSorting", enableFavoriteSorting)); // query parameter
            if (enableImages != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImages", enableImages)); // query parameter
            if (imageTypeLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ImageTypeLimit", imageTypeLimit)); // query parameter
            if (enableImageTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImageTypes", enableImageTypes)); // query parameter
            if (fields != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Fields", fields)); // query parameter
            if (addCurrentProgram != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AddCurrentProgram", addCurrentProgram)); // query parameter
            if (enableUserData != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableUserData", enableUserData)); // query parameter
            if (channelIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ChannelIds", channelIds)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvEPG", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultLiveTVApiEpgRow>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultLiveTVApiEpgRow) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultLiveTVApiEpgRow)));
        }

        /// <summary>
        /// Gets the top level live tv folder Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>BaseItemDto</returns>
        public BaseItemDto GetLivetvFolder ()
        {
             ApiResponse<BaseItemDto> localVarResponse = GetLivetvFolderWithHttpInfo();
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets the top level live tv folder Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of BaseItemDto</returns>
        public ApiResponse< BaseItemDto > GetLivetvFolderWithHttpInfo ()
        {

            var localVarPath = "/LiveTv/Folder";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvFolder", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BaseItemDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (BaseItemDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BaseItemDto)));
        }

        /// <summary>
        /// Gets the top level live tv folder Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of BaseItemDto</returns>
        public async System.Threading.Tasks.Task<BaseItemDto> GetLivetvFolderAsync ()
        {
             ApiResponse<BaseItemDto> localVarResponse = await GetLivetvFolderAsyncWithHttpInfo();
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets the top level live tv folder Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (BaseItemDto)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BaseItemDto>> GetLivetvFolderAsyncWithHttpInfo ()
        {

            var localVarPath = "/LiveTv/Folder";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvFolder", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BaseItemDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (BaseItemDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BaseItemDto)));
        }

        /// <summary>
        /// Gets guide info Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>LiveTvGuideInfo</returns>
        public LiveTvGuideInfo GetLivetvGuideinfo ()
        {
             ApiResponse<LiveTvGuideInfo> localVarResponse = GetLivetvGuideinfoWithHttpInfo();
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets guide info Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of LiveTvGuideInfo</returns>
        public ApiResponse< LiveTvGuideInfo > GetLivetvGuideinfoWithHttpInfo ()
        {

            var localVarPath = "/LiveTv/GuideInfo";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvGuideinfo", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<LiveTvGuideInfo>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (LiveTvGuideInfo) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(LiveTvGuideInfo)));
        }

        /// <summary>
        /// Gets guide info Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of LiveTvGuideInfo</returns>
        public async System.Threading.Tasks.Task<LiveTvGuideInfo> GetLivetvGuideinfoAsync ()
        {
             ApiResponse<LiveTvGuideInfo> localVarResponse = await GetLivetvGuideinfoAsyncWithHttpInfo();
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets guide info Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (LiveTvGuideInfo)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<LiveTvGuideInfo>> GetLivetvGuideinfoAsyncWithHttpInfo ()
        {

            var localVarPath = "/LiveTv/GuideInfo";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvGuideinfo", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<LiveTvGuideInfo>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (LiveTvGuideInfo) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(LiveTvGuideInfo)));
        }

        /// <summary>
        /// Gets available live tv services. Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>LiveTvLiveTvInfo</returns>
        public LiveTvLiveTvInfo GetLivetvInfo ()
        {
             ApiResponse<LiveTvLiveTvInfo> localVarResponse = GetLivetvInfoWithHttpInfo();
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets available live tv services. Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of LiveTvLiveTvInfo</returns>
        public ApiResponse< LiveTvLiveTvInfo > GetLivetvInfoWithHttpInfo ()
        {

            var localVarPath = "/LiveTv/Info";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvInfo", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<LiveTvLiveTvInfo>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (LiveTvLiveTvInfo) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(LiveTvLiveTvInfo)));
        }

        /// <summary>
        /// Gets available live tv services. Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of LiveTvLiveTvInfo</returns>
        public async System.Threading.Tasks.Task<LiveTvLiveTvInfo> GetLivetvInfoAsync ()
        {
             ApiResponse<LiveTvLiveTvInfo> localVarResponse = await GetLivetvInfoAsyncWithHttpInfo();
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets available live tv services. Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (LiveTvLiveTvInfo)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<LiveTvLiveTvInfo>> GetLivetvInfoAsyncWithHttpInfo ()
        {

            var localVarPath = "/LiveTv/Info";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvInfo", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<LiveTvLiveTvInfo>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (LiveTvLiveTvInfo) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(LiveTvLiveTvInfo)));
        }

        /// <summary>
        /// Gets current listing providers Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">Channel id</param>
        /// <returns>List&lt;LiveTvListingsProviderInfo&gt;</returns>
        public List<LiveTvListingsProviderInfo> GetLivetvListingproviders (string channelId)
        {
             ApiResponse<List<LiveTvListingsProviderInfo>> localVarResponse = GetLivetvListingprovidersWithHttpInfo(channelId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets current listing providers Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">Channel id</param>
        /// <returns>ApiResponse of List&lt;LiveTvListingsProviderInfo&gt;</returns>
        public ApiResponse< List<LiveTvListingsProviderInfo> > GetLivetvListingprovidersWithHttpInfo (string channelId)
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
                throw new ApiException(400, "Missing required parameter 'channelId' when calling LiveTvServiceApi->GetLivetvListingproviders");

            var localVarPath = "/LiveTv/ListingProviders";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (channelId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ChannelId", channelId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvListingproviders", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<LiveTvListingsProviderInfo>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<LiveTvListingsProviderInfo>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<LiveTvListingsProviderInfo>)));
        }

        /// <summary>
        /// Gets current listing providers Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">Channel id</param>
        /// <returns>Task of List&lt;LiveTvListingsProviderInfo&gt;</returns>
        public async System.Threading.Tasks.Task<List<LiveTvListingsProviderInfo>> GetLivetvListingprovidersAsync (string channelId)
        {
             ApiResponse<List<LiveTvListingsProviderInfo>> localVarResponse = await GetLivetvListingprovidersAsyncWithHttpInfo(channelId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets current listing providers Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">Channel id</param>
        /// <returns>Task of ApiResponse (List&lt;LiveTvListingsProviderInfo&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<LiveTvListingsProviderInfo>>> GetLivetvListingprovidersAsyncWithHttpInfo (string channelId)
        {
            // verify the required parameter 'channelId' is set
            if (channelId == null)
                throw new ApiException(400, "Missing required parameter 'channelId' when calling LiveTvServiceApi->GetLivetvListingproviders");

            var localVarPath = "/LiveTv/ListingProviders";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (channelId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ChannelId", channelId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvListingproviders", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<LiveTvListingsProviderInfo>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<LiveTvListingsProviderInfo>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<LiveTvListingsProviderInfo>)));
        }

        /// <summary>
        /// Gets listing provider Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>List&lt;LiveTVApiListingProviderTypeInfo&gt;</returns>
        public List<LiveTVApiListingProviderTypeInfo> GetLivetvListingprovidersAvailable ()
        {
             ApiResponse<List<LiveTVApiListingProviderTypeInfo>> localVarResponse = GetLivetvListingprovidersAvailableWithHttpInfo();
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets listing provider Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of List&lt;LiveTVApiListingProviderTypeInfo&gt;</returns>
        public ApiResponse< List<LiveTVApiListingProviderTypeInfo> > GetLivetvListingprovidersAvailableWithHttpInfo ()
        {

            var localVarPath = "/LiveTv/ListingProviders/Available";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvListingprovidersAvailable", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<LiveTVApiListingProviderTypeInfo>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<LiveTVApiListingProviderTypeInfo>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<LiveTVApiListingProviderTypeInfo>)));
        }

        /// <summary>
        /// Gets listing provider Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of List&lt;LiveTVApiListingProviderTypeInfo&gt;</returns>
        public async System.Threading.Tasks.Task<List<LiveTVApiListingProviderTypeInfo>> GetLivetvListingprovidersAvailableAsync ()
        {
             ApiResponse<List<LiveTVApiListingProviderTypeInfo>> localVarResponse = await GetLivetvListingprovidersAvailableAsyncWithHttpInfo();
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets listing provider Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (List&lt;LiveTVApiListingProviderTypeInfo&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<LiveTVApiListingProviderTypeInfo>>> GetLivetvListingprovidersAvailableAsyncWithHttpInfo ()
        {

            var localVarPath = "/LiveTv/ListingProviders/Available";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvListingprovidersAvailable", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<LiveTVApiListingProviderTypeInfo>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<LiveTVApiListingProviderTypeInfo>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<LiveTVApiListingProviderTypeInfo>)));
        }

        /// <summary>
        ///  Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>LiveTvListingsProviderInfo</returns>
        public LiveTvListingsProviderInfo GetLivetvListingprovidersDefault ()
        {
             ApiResponse<LiveTvListingsProviderInfo> localVarResponse = GetLivetvListingprovidersDefaultWithHttpInfo();
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of LiveTvListingsProviderInfo</returns>
        public ApiResponse< LiveTvListingsProviderInfo > GetLivetvListingprovidersDefaultWithHttpInfo ()
        {

            var localVarPath = "/LiveTv/ListingProviders/Default";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvListingprovidersDefault", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<LiveTvListingsProviderInfo>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (LiveTvListingsProviderInfo) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(LiveTvListingsProviderInfo)));
        }

        /// <summary>
        ///  Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of LiveTvListingsProviderInfo</returns>
        public async System.Threading.Tasks.Task<LiveTvListingsProviderInfo> GetLivetvListingprovidersDefaultAsync ()
        {
             ApiResponse<LiveTvListingsProviderInfo> localVarResponse = await GetLivetvListingprovidersDefaultAsyncWithHttpInfo();
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (LiveTvListingsProviderInfo)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<LiveTvListingsProviderInfo>> GetLivetvListingprovidersDefaultAsyncWithHttpInfo ()
        {

            var localVarPath = "/LiveTv/ListingProviders/Default";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvListingprovidersDefault", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<LiveTvListingsProviderInfo>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (LiveTvListingsProviderInfo) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(LiveTvListingsProviderInfo)));
        }

        /// <summary>
        /// Gets available lineups Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Provider id (optional)</param>
        /// <param name="type">Provider Type (optional)</param>
        /// <param name="location">Location (optional)</param>
        /// <param name="country">Country (optional)</param>
        /// <returns>List&lt;NameIdPair&gt;</returns>
        public List<NameIdPair> GetLivetvListingprovidersLineups (string id, string type, string location, string country)
        {
             ApiResponse<List<NameIdPair>> localVarResponse = GetLivetvListingprovidersLineupsWithHttpInfo(id, type, location, country);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets available lineups Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Provider id (optional)</param>
        /// <param name="type">Provider Type (optional)</param>
        /// <param name="location">Location (optional)</param>
        /// <param name="country">Country (optional)</param>
        /// <returns>ApiResponse of List&lt;NameIdPair&gt;</returns>
        public ApiResponse< List<NameIdPair> > GetLivetvListingprovidersLineupsWithHttpInfo (string id, string type, string location, string country)
        {

            var localVarPath = "/LiveTv/ListingProviders/Lineups";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Id", id)); // query parameter
            if (type != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Type", type)); // query parameter
            if (location != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Location", location)); // query parameter
            if (country != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Country", country)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvListingprovidersLineups", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<NameIdPair>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<NameIdPair>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<NameIdPair>)));
        }

        /// <summary>
        /// Gets available lineups Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Provider id (optional)</param>
        /// <param name="type">Provider Type (optional)</param>
        /// <param name="location">Location (optional)</param>
        /// <param name="country">Country (optional)</param>
        /// <returns>Task of List&lt;NameIdPair&gt;</returns>
        public async System.Threading.Tasks.Task<List<NameIdPair>> GetLivetvListingprovidersLineupsAsync (string id, string type, string location, string country)
        {
             ApiResponse<List<NameIdPair>> localVarResponse = await GetLivetvListingprovidersLineupsAsyncWithHttpInfo(id, type, location, country);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets available lineups Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Provider id (optional)</param>
        /// <param name="type">Provider Type (optional)</param>
        /// <param name="location">Location (optional)</param>
        /// <param name="country">Country (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;NameIdPair&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<NameIdPair>>> GetLivetvListingprovidersLineupsAsyncWithHttpInfo (string id, string type, string location, string country)
        {

            var localVarPath = "/LiveTv/ListingProviders/Lineups";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Id", id)); // query parameter
            if (type != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Type", type)); // query parameter
            if (location != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Location", location)); // query parameter
            if (country != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Country", country)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvListingprovidersLineups", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<NameIdPair>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<NameIdPair>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<NameIdPair>)));
        }

        /// <summary>
        /// Gets available lineups Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns></returns>
        public void GetLivetvListingprovidersSchedulesdirectCountries ()
        {
             GetLivetvListingprovidersSchedulesdirectCountriesWithHttpInfo();
        }

        /// <summary>
        /// Gets available lineups Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> GetLivetvListingprovidersSchedulesdirectCountriesWithHttpInfo ()
        {

            var localVarPath = "/LiveTv/ListingProviders/SchedulesDirect/Countries";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvListingprovidersSchedulesdirectCountries", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Gets available lineups Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task GetLivetvListingprovidersSchedulesdirectCountriesAsync ()
        {
             await GetLivetvListingprovidersSchedulesdirectCountriesAsyncWithHttpInfo();

        }

        /// <summary>
        /// Gets available lineups Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> GetLivetvListingprovidersSchedulesdirectCountriesAsyncWithHttpInfo ()
        {

            var localVarPath = "/LiveTv/ListingProviders/SchedulesDirect/Countries";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvListingprovidersSchedulesdirectCountries", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Gets a live tv channel No authentication required
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns></returns>
        public void GetLivetvLiverecordingsByIdStream (string id)
        {
             GetLivetvLiverecordingsByIdStreamWithHttpInfo(id);
        }

        /// <summary>
        /// Gets a live tv channel No authentication required
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> GetLivetvLiverecordingsByIdStreamWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->GetLivetvLiverecordingsByIdStream");

            var localVarPath = "/LiveTv/LiveRecordings/{Id}/stream";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvLiverecordingsByIdStream", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Gets a live tv channel No authentication required
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task GetLivetvLiverecordingsByIdStreamAsync (string id)
        {
             await GetLivetvLiverecordingsByIdStreamAsyncWithHttpInfo(id);

        }

        /// <summary>
        /// Gets a live tv channel No authentication required
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> GetLivetvLiverecordingsByIdStreamAsyncWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->GetLivetvLiverecordingsByIdStream");

            var localVarPath = "/LiveTv/LiveRecordings/{Id}/stream";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvLiverecordingsByIdStream", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Gets a live tv channel No authentication required
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="container"></param>
        /// <returns></returns>
        public void GetLivetvLivestreamfilesByIdStreamByContainer (string id, string container)
        {
             GetLivetvLivestreamfilesByIdStreamByContainerWithHttpInfo(id, container);
        }

        /// <summary>
        /// Gets a live tv channel No authentication required
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="container"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> GetLivetvLivestreamfilesByIdStreamByContainerWithHttpInfo (string id, string container)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->GetLivetvLivestreamfilesByIdStreamByContainer");
            // verify the required parameter 'container' is set
            if (container == null)
                throw new ApiException(400, "Missing required parameter 'container' when calling LiveTvServiceApi->GetLivetvLivestreamfilesByIdStreamByContainer");

            var localVarPath = "/LiveTv/LiveStreamFiles/{Id}/stream.{Container}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (container != null) localVarPathParams.Add("Container", this.Configuration.ApiClient.ParameterToString(container)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvLivestreamfilesByIdStreamByContainer", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Gets a live tv channel No authentication required
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="container"></param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task GetLivetvLivestreamfilesByIdStreamByContainerAsync (string id, string container)
        {
             await GetLivetvLivestreamfilesByIdStreamByContainerAsyncWithHttpInfo(id, container);

        }

        /// <summary>
        /// Gets a live tv channel No authentication required
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="container"></param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> GetLivetvLivestreamfilesByIdStreamByContainerAsyncWithHttpInfo (string id, string container)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->GetLivetvLivestreamfilesByIdStreamByContainer");
            // verify the required parameter 'container' is set
            if (container == null)
                throw new ApiException(400, "Missing required parameter 'container' when calling LiveTvServiceApi->GetLivetvLivestreamfilesByIdStreamByContainer");

            var localVarPath = "/LiveTv/LiveStreamFiles/{Id}/stream.{Container}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (container != null) localVarPathParams.Add("Container", this.Configuration.ApiClient.ParameterToString(container)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvLivestreamfilesByIdStreamByContainer", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Gets the channel management list Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <returns>QueryResultEmbyLiveTVChannelManagementInfo</returns>
        public QueryResultEmbyLiveTVChannelManagementInfo GetLivetvManageChannels (int? startIndex, int? limit, string sortBy, string sortOrder)
        {
             ApiResponse<QueryResultEmbyLiveTVChannelManagementInfo> localVarResponse = GetLivetvManageChannelsWithHttpInfo(startIndex, limit, sortBy, sortOrder);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets the channel management list Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <returns>ApiResponse of QueryResultEmbyLiveTVChannelManagementInfo</returns>
        public ApiResponse< QueryResultEmbyLiveTVChannelManagementInfo > GetLivetvManageChannelsWithHttpInfo (int? startIndex, int? limit, string sortBy, string sortOrder)
        {

            var localVarPath = "/LiveTv/Manage/Channels";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (startIndex != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StartIndex", startIndex)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Limit", limit)); // query parameter
            if (sortBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortBy", sortBy)); // query parameter
            if (sortOrder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortOrder", sortOrder)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvManageChannels", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultEmbyLiveTVChannelManagementInfo>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultEmbyLiveTVChannelManagementInfo) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultEmbyLiveTVChannelManagementInfo)));
        }

        /// <summary>
        /// Gets the channel management list Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <returns>Task of QueryResultEmbyLiveTVChannelManagementInfo</returns>
        public async System.Threading.Tasks.Task<QueryResultEmbyLiveTVChannelManagementInfo> GetLivetvManageChannelsAsync (int? startIndex, int? limit, string sortBy, string sortOrder)
        {
             ApiResponse<QueryResultEmbyLiveTVChannelManagementInfo> localVarResponse = await GetLivetvManageChannelsAsyncWithHttpInfo(startIndex, limit, sortBy, sortOrder);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets the channel management list Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <returns>Task of ApiResponse (QueryResultEmbyLiveTVChannelManagementInfo)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<QueryResultEmbyLiveTVChannelManagementInfo>> GetLivetvManageChannelsAsyncWithHttpInfo (int? startIndex, int? limit, string sortBy, string sortOrder)
        {

            var localVarPath = "/LiveTv/Manage/Channels";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (startIndex != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StartIndex", startIndex)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Limit", limit)); // query parameter
            if (sortBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortBy", sortBy)); // query parameter
            if (sortOrder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortOrder", sortOrder)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvManageChannels", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultEmbyLiveTVChannelManagementInfo>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultEmbyLiveTVChannelManagementInfo) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultEmbyLiveTVChannelManagementInfo)));
        }

        /// <summary>
        /// Gets available live tv epgs.. Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelIds">The channels to return guide information for. (optional)</param>
        /// <param name="userId">Optional filter by user id. (optional)</param>
        /// <param name="hasAired">Optional. Filter by programs that have completed airing, or not. (optional)</param>
        /// <param name="minStartDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxStartDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minEndDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxEndDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <returns>QueryResultBaseItemDto</returns>
        public QueryResultBaseItemDto GetLivetvPrograms (string channelIds, string userId, bool? hasAired, string minStartDate, string maxStartDate, string minEndDate, string maxEndDate, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, int? startIndex, int? limit, string sortBy, string sortOrder, string genreIds, bool? enableImages, int? imageTypeLimit, string enableImageTypes, bool? enableUserData, string fields)
        {
             ApiResponse<QueryResultBaseItemDto> localVarResponse = GetLivetvProgramsWithHttpInfo(channelIds, userId, hasAired, minStartDate, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, startIndex, limit, sortBy, sortOrder, genreIds, enableImages, imageTypeLimit, enableImageTypes, enableUserData, fields);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets available live tv epgs.. Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelIds">The channels to return guide information for. (optional)</param>
        /// <param name="userId">Optional filter by user id. (optional)</param>
        /// <param name="hasAired">Optional. Filter by programs that have completed airing, or not. (optional)</param>
        /// <param name="minStartDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxStartDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minEndDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxEndDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <returns>ApiResponse of QueryResultBaseItemDto</returns>
        public ApiResponse< QueryResultBaseItemDto > GetLivetvProgramsWithHttpInfo (string channelIds, string userId, bool? hasAired, string minStartDate, string maxStartDate, string minEndDate, string maxEndDate, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, int? startIndex, int? limit, string sortBy, string sortOrder, string genreIds, bool? enableImages, int? imageTypeLimit, string enableImageTypes, bool? enableUserData, string fields)
        {

            var localVarPath = "/LiveTv/Programs";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (channelIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ChannelIds", channelIds)); // query parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "UserId", userId)); // query parameter
            if (hasAired != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasAired", hasAired)); // query parameter
            if (minStartDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinStartDate", minStartDate)); // query parameter
            if (maxStartDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxStartDate", maxStartDate)); // query parameter
            if (minEndDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinEndDate", minEndDate)); // query parameter
            if (maxEndDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxEndDate", maxEndDate)); // query parameter
            if (isMovie != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsMovie", isMovie)); // query parameter
            if (isSeries != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSeries", isSeries)); // query parameter
            if (isNews != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsNews", isNews)); // query parameter
            if (isKids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsKids", isKids)); // query parameter
            if (isSports != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSports", isSports)); // query parameter
            if (startIndex != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StartIndex", startIndex)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Limit", limit)); // query parameter
            if (sortBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortBy", sortBy)); // query parameter
            if (sortOrder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortOrder", sortOrder)); // query parameter
            if (genreIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "GenreIds", genreIds)); // query parameter
            if (enableImages != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImages", enableImages)); // query parameter
            if (imageTypeLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ImageTypeLimit", imageTypeLimit)); // query parameter
            if (enableImageTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImageTypes", enableImageTypes)); // query parameter
            if (enableUserData != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableUserData", enableUserData)); // query parameter
            if (fields != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Fields", fields)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvPrograms", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultBaseItemDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultBaseItemDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultBaseItemDto)));
        }

        /// <summary>
        /// Gets available live tv epgs.. Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelIds">The channels to return guide information for. (optional)</param>
        /// <param name="userId">Optional filter by user id. (optional)</param>
        /// <param name="hasAired">Optional. Filter by programs that have completed airing, or not. (optional)</param>
        /// <param name="minStartDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxStartDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minEndDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxEndDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <returns>Task of QueryResultBaseItemDto</returns>
        public async System.Threading.Tasks.Task<QueryResultBaseItemDto> GetLivetvProgramsAsync (string channelIds, string userId, bool? hasAired, string minStartDate, string maxStartDate, string minEndDate, string maxEndDate, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, int? startIndex, int? limit, string sortBy, string sortOrder, string genreIds, bool? enableImages, int? imageTypeLimit, string enableImageTypes, bool? enableUserData, string fields)
        {
             ApiResponse<QueryResultBaseItemDto> localVarResponse = await GetLivetvProgramsAsyncWithHttpInfo(channelIds, userId, hasAired, minStartDate, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, startIndex, limit, sortBy, sortOrder, genreIds, enableImages, imageTypeLimit, enableImageTypes, enableUserData, fields);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets available live tv epgs.. Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelIds">The channels to return guide information for. (optional)</param>
        /// <param name="userId">Optional filter by user id. (optional)</param>
        /// <param name="hasAired">Optional. Filter by programs that have completed airing, or not. (optional)</param>
        /// <param name="minStartDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxStartDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minEndDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxEndDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <returns>Task of ApiResponse (QueryResultBaseItemDto)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<QueryResultBaseItemDto>> GetLivetvProgramsAsyncWithHttpInfo (string channelIds, string userId, bool? hasAired, string minStartDate, string maxStartDate, string minEndDate, string maxEndDate, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, int? startIndex, int? limit, string sortBy, string sortOrder, string genreIds, bool? enableImages, int? imageTypeLimit, string enableImageTypes, bool? enableUserData, string fields)
        {

            var localVarPath = "/LiveTv/Programs";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (channelIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ChannelIds", channelIds)); // query parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "UserId", userId)); // query parameter
            if (hasAired != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasAired", hasAired)); // query parameter
            if (minStartDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinStartDate", minStartDate)); // query parameter
            if (maxStartDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxStartDate", maxStartDate)); // query parameter
            if (minEndDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinEndDate", minEndDate)); // query parameter
            if (maxEndDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxEndDate", maxEndDate)); // query parameter
            if (isMovie != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsMovie", isMovie)); // query parameter
            if (isSeries != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSeries", isSeries)); // query parameter
            if (isNews != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsNews", isNews)); // query parameter
            if (isKids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsKids", isKids)); // query parameter
            if (isSports != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSports", isSports)); // query parameter
            if (startIndex != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StartIndex", startIndex)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Limit", limit)); // query parameter
            if (sortBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortBy", sortBy)); // query parameter
            if (sortOrder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortOrder", sortOrder)); // query parameter
            if (genreIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "GenreIds", genreIds)); // query parameter
            if (enableImages != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImages", enableImages)); // query parameter
            if (imageTypeLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ImageTypeLimit", imageTypeLimit)); // query parameter
            if (enableImageTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImageTypes", enableImageTypes)); // query parameter
            if (enableUserData != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableUserData", enableUserData)); // query parameter
            if (fields != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Fields", fields)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvPrograms", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultBaseItemDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultBaseItemDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultBaseItemDto)));
        }

        /// <summary>
        /// Gets available live tv epgs.. Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">Optional filter by user id. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="isAiring">Optional. Filter by programs that are currently airing, or not. (optional)</param>
        /// <param name="hasAired">Optional. Filter by programs that have completed airing, or not. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <returns>QueryResultBaseItemDto</returns>
        public QueryResultBaseItemDto GetLivetvProgramsRecommended (string userId, int? limit, bool? isAiring, bool? hasAired, bool? isSeries, bool? isMovie, bool? isNews, bool? isKids, bool? isSports, bool? enableImages, int? imageTypeLimit, string enableImageTypes, string genreIds, string fields, bool? enableUserData)
        {
             ApiResponse<QueryResultBaseItemDto> localVarResponse = GetLivetvProgramsRecommendedWithHttpInfo(userId, limit, isAiring, hasAired, isSeries, isMovie, isNews, isKids, isSports, enableImages, imageTypeLimit, enableImageTypes, genreIds, fields, enableUserData);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets available live tv epgs.. Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">Optional filter by user id. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="isAiring">Optional. Filter by programs that are currently airing, or not. (optional)</param>
        /// <param name="hasAired">Optional. Filter by programs that have completed airing, or not. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <returns>ApiResponse of QueryResultBaseItemDto</returns>
        public ApiResponse< QueryResultBaseItemDto > GetLivetvProgramsRecommendedWithHttpInfo (string userId, int? limit, bool? isAiring, bool? hasAired, bool? isSeries, bool? isMovie, bool? isNews, bool? isKids, bool? isSports, bool? enableImages, int? imageTypeLimit, string enableImageTypes, string genreIds, string fields, bool? enableUserData)
        {

            var localVarPath = "/LiveTv/Programs/Recommended";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "UserId", userId)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Limit", limit)); // query parameter
            if (isAiring != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsAiring", isAiring)); // query parameter
            if (hasAired != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasAired", hasAired)); // query parameter
            if (isSeries != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSeries", isSeries)); // query parameter
            if (isMovie != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsMovie", isMovie)); // query parameter
            if (isNews != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsNews", isNews)); // query parameter
            if (isKids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsKids", isKids)); // query parameter
            if (isSports != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSports", isSports)); // query parameter
            if (enableImages != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImages", enableImages)); // query parameter
            if (imageTypeLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ImageTypeLimit", imageTypeLimit)); // query parameter
            if (enableImageTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImageTypes", enableImageTypes)); // query parameter
            if (genreIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "GenreIds", genreIds)); // query parameter
            if (fields != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Fields", fields)); // query parameter
            if (enableUserData != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableUserData", enableUserData)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvProgramsRecommended", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultBaseItemDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultBaseItemDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultBaseItemDto)));
        }

        /// <summary>
        /// Gets available live tv epgs.. Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">Optional filter by user id. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="isAiring">Optional. Filter by programs that are currently airing, or not. (optional)</param>
        /// <param name="hasAired">Optional. Filter by programs that have completed airing, or not. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <returns>Task of QueryResultBaseItemDto</returns>
        public async System.Threading.Tasks.Task<QueryResultBaseItemDto> GetLivetvProgramsRecommendedAsync (string userId, int? limit, bool? isAiring, bool? hasAired, bool? isSeries, bool? isMovie, bool? isNews, bool? isKids, bool? isSports, bool? enableImages, int? imageTypeLimit, string enableImageTypes, string genreIds, string fields, bool? enableUserData)
        {
             ApiResponse<QueryResultBaseItemDto> localVarResponse = await GetLivetvProgramsRecommendedAsyncWithHttpInfo(userId, limit, isAiring, hasAired, isSeries, isMovie, isNews, isKids, isSports, enableImages, imageTypeLimit, enableImageTypes, genreIds, fields, enableUserData);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets available live tv epgs.. Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">Optional filter by user id. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="isAiring">Optional. Filter by programs that are currently airing, or not. (optional)</param>
        /// <param name="hasAired">Optional. Filter by programs that have completed airing, or not. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <returns>Task of ApiResponse (QueryResultBaseItemDto)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<QueryResultBaseItemDto>> GetLivetvProgramsRecommendedAsyncWithHttpInfo (string userId, int? limit, bool? isAiring, bool? hasAired, bool? isSeries, bool? isMovie, bool? isNews, bool? isKids, bool? isSports, bool? enableImages, int? imageTypeLimit, string enableImageTypes, string genreIds, string fields, bool? enableUserData)
        {

            var localVarPath = "/LiveTv/Programs/Recommended";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "UserId", userId)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Limit", limit)); // query parameter
            if (isAiring != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsAiring", isAiring)); // query parameter
            if (hasAired != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasAired", hasAired)); // query parameter
            if (isSeries != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSeries", isSeries)); // query parameter
            if (isMovie != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsMovie", isMovie)); // query parameter
            if (isNews != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsNews", isNews)); // query parameter
            if (isKids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsKids", isKids)); // query parameter
            if (isSports != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSports", isSports)); // query parameter
            if (enableImages != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImages", enableImages)); // query parameter
            if (imageTypeLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ImageTypeLimit", imageTypeLimit)); // query parameter
            if (enableImageTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImageTypes", enableImageTypes)); // query parameter
            if (genreIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "GenreIds", genreIds)); // query parameter
            if (fields != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Fields", fields)); // query parameter
            if (enableUserData != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableUserData", enableUserData)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvProgramsRecommended", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultBaseItemDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultBaseItemDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultBaseItemDto)));
        }

        /// <summary>
        /// Gets live tv recordings Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">Optional filter by channel id. (optional)</param>
        /// <param name="status">Optional filter by recording status. (optional)</param>
        /// <param name="isInProgress">Optional filter by recordings that are in progress, or not. (optional)</param>
        /// <param name="seriesTimerId">Optional filter by recordings belonging to a series timer (optional)</param>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns></returns>
        public void GetLivetvRecordings (string channelId, LiveTvRecordingStatus status, bool? isInProgress, string seriesTimerId, string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan)
        {
             GetLivetvRecordingsWithHttpInfo(channelId, status, isInProgress, seriesTimerId, artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, artistStartsWithOrGreater, albumArtistStartsWithOrGreater, nameStartsWith, nameLessThan);
        }

        /// <summary>
        /// Gets live tv recordings Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">Optional filter by channel id. (optional)</param>
        /// <param name="status">Optional filter by recording status. (optional)</param>
        /// <param name="isInProgress">Optional filter by recordings that are in progress, or not. (optional)</param>
        /// <param name="seriesTimerId">Optional filter by recordings belonging to a series timer (optional)</param>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> GetLivetvRecordingsWithHttpInfo (string channelId, LiveTvRecordingStatus status, bool? isInProgress, string seriesTimerId, string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan)
        {

            var localVarPath = "/LiveTv/Recordings";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (channelId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ChannelId", channelId)); // query parameter
            if (status != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Status", status)); // query parameter
            if (isInProgress != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsInProgress", isInProgress)); // query parameter
            if (seriesTimerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SeriesTimerId", seriesTimerId)); // query parameter
            if (artistType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ArtistType", artistType)); // query parameter
            if (maxOfficialRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxOfficialRating", maxOfficialRating)); // query parameter
            if (hasThemeSong != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasThemeSong", hasThemeSong)); // query parameter
            if (hasThemeVideo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasThemeVideo", hasThemeVideo)); // query parameter
            if (hasSubtitles != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasSubtitles", hasSubtitles)); // query parameter
            if (hasSpecialFeature != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasSpecialFeature", hasSpecialFeature)); // query parameter
            if (hasTrailer != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasTrailer", hasTrailer)); // query parameter
            if (adjacentTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AdjacentTo", adjacentTo)); // query parameter
            if (minIndexNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinIndexNumber", minIndexNumber)); // query parameter
            if (minPlayers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinPlayers", minPlayers)); // query parameter
            if (maxPlayers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxPlayers", maxPlayers)); // query parameter
            if (parentIndexNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ParentIndexNumber", parentIndexNumber)); // query parameter
            if (hasParentalRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasParentalRating", hasParentalRating)); // query parameter
            if (isHD != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsHD", isHD)); // query parameter
            if (locationTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "LocationTypes", locationTypes)); // query parameter
            if (excludeLocationTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ExcludeLocationTypes", excludeLocationTypes)); // query parameter
            if (isMissing != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsMissing", isMissing)); // query parameter
            if (isUnaired != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsUnaired", isUnaired)); // query parameter
            if (minCommunityRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinCommunityRating", minCommunityRating)); // query parameter
            if (minCriticRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinCriticRating", minCriticRating)); // query parameter
            if (airedDuringSeason != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AiredDuringSeason", airedDuringSeason)); // query parameter
            if (minPremiereDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinPremiereDate", minPremiereDate)); // query parameter
            if (minDateLastSaved != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinDateLastSaved", minDateLastSaved)); // query parameter
            if (minDateLastSavedForUser != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinDateLastSavedForUser", minDateLastSavedForUser)); // query parameter
            if (maxPremiereDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxPremiereDate", maxPremiereDate)); // query parameter
            if (hasOverview != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasOverview", hasOverview)); // query parameter
            if (hasImdbId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasImdbId", hasImdbId)); // query parameter
            if (hasTmdbId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasTmdbId", hasTmdbId)); // query parameter
            if (hasTvdbId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasTvdbId", hasTvdbId)); // query parameter
            if (excludeItemIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ExcludeItemIds", excludeItemIds)); // query parameter
            if (startIndex != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StartIndex", startIndex)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Limit", limit)); // query parameter
            if (recursive != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Recursive", recursive)); // query parameter
            if (searchTerm != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SearchTerm", searchTerm)); // query parameter
            if (sortOrder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortOrder", sortOrder)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ParentId", parentId)); // query parameter
            if (fields != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Fields", fields)); // query parameter
            if (excludeItemTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ExcludeItemTypes", excludeItemTypes)); // query parameter
            if (includeItemTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IncludeItemTypes", includeItemTypes)); // query parameter
            if (anyProviderIdEquals != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AnyProviderIdEquals", anyProviderIdEquals)); // query parameter
            if (filters != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Filters", filters)); // query parameter
            if (isFavorite != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsFavorite", isFavorite)); // query parameter
            if (isMovie != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsMovie", isMovie)); // query parameter
            if (isSeries != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSeries", isSeries)); // query parameter
            if (isNews != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsNews", isNews)); // query parameter
            if (isKids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsKids", isKids)); // query parameter
            if (isSports != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSports", isSports)); // query parameter
            if (mediaTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MediaTypes", mediaTypes)); // query parameter
            if (imageTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ImageTypes", imageTypes)); // query parameter
            if (sortBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortBy", sortBy)); // query parameter
            if (isPlayed != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsPlayed", isPlayed)); // query parameter
            if (genres != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Genres", genres)); // query parameter
            if (officialRatings != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "OfficialRatings", officialRatings)); // query parameter
            if (tags != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Tags", tags)); // query parameter
            if (years != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Years", years)); // query parameter
            if (enableImages != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImages", enableImages)); // query parameter
            if (enableUserData != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableUserData", enableUserData)); // query parameter
            if (imageTypeLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ImageTypeLimit", imageTypeLimit)); // query parameter
            if (enableImageTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImageTypes", enableImageTypes)); // query parameter
            if (person != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Person", person)); // query parameter
            if (personIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "PersonIds", personIds)); // query parameter
            if (personTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "PersonTypes", personTypes)); // query parameter
            if (studios != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Studios", studios)); // query parameter
            if (studioIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StudioIds", studioIds)); // query parameter
            if (artists != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Artists", artists)); // query parameter
            if (artistIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ArtistIds", artistIds)); // query parameter
            if (albums != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Albums", albums)); // query parameter
            if (ids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Ids", ids)); // query parameter
            if (videoTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "VideoTypes", videoTypes)); // query parameter
            if (containers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Containers", containers)); // query parameter
            if (audioCodecs != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AudioCodecs", audioCodecs)); // query parameter
            if (videoCodecs != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "VideoCodecs", videoCodecs)); // query parameter
            if (subtitleCodecs != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SubtitleCodecs", subtitleCodecs)); // query parameter
            if (path != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Path", path)); // query parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "UserId", userId)); // query parameter
            if (minOfficialRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinOfficialRating", minOfficialRating)); // query parameter
            if (isLocked != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsLocked", isLocked)); // query parameter
            if (isPlaceHolder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsPlaceHolder", isPlaceHolder)); // query parameter
            if (hasOfficialRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasOfficialRating", hasOfficialRating)); // query parameter
            if (groupItemsIntoCollections != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "GroupItemsIntoCollections", groupItemsIntoCollections)); // query parameter
            if (is3D != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Is3D", is3D)); // query parameter
            if (seriesStatus != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SeriesStatus", seriesStatus)); // query parameter
            if (nameStartsWithOrGreater != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "NameStartsWithOrGreater", nameStartsWithOrGreater)); // query parameter
            if (artistStartsWithOrGreater != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ArtistStartsWithOrGreater", artistStartsWithOrGreater)); // query parameter
            if (albumArtistStartsWithOrGreater != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AlbumArtistStartsWithOrGreater", albumArtistStartsWithOrGreater)); // query parameter
            if (nameStartsWith != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "NameStartsWith", nameStartsWith)); // query parameter
            if (nameLessThan != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "NameLessThan", nameLessThan)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvRecordings", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Gets live tv recordings Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">Optional filter by channel id. (optional)</param>
        /// <param name="status">Optional filter by recording status. (optional)</param>
        /// <param name="isInProgress">Optional filter by recordings that are in progress, or not. (optional)</param>
        /// <param name="seriesTimerId">Optional filter by recordings belonging to a series timer (optional)</param>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task GetLivetvRecordingsAsync (string channelId, LiveTvRecordingStatus status, bool? isInProgress, string seriesTimerId, string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan)
        {
             await GetLivetvRecordingsAsyncWithHttpInfo(channelId, status, isInProgress, seriesTimerId, artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, artistStartsWithOrGreater, albumArtistStartsWithOrGreater, nameStartsWith, nameLessThan);

        }

        /// <summary>
        /// Gets live tv recordings Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">Optional filter by channel id. (optional)</param>
        /// <param name="status">Optional filter by recording status. (optional)</param>
        /// <param name="isInProgress">Optional filter by recordings that are in progress, or not. (optional)</param>
        /// <param name="seriesTimerId">Optional filter by recordings belonging to a series timer (optional)</param>
        /// <param name="artistType">Artist or AlbumArtist (optional)</param>
        /// <param name="maxOfficialRating">Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="hasThemeSong">Optional filter by items with theme songs. (optional)</param>
        /// <param name="hasThemeVideo">Optional filter by items with theme videos. (optional)</param>
        /// <param name="hasSubtitles">Optional filter by items with subtitles. (optional)</param>
        /// <param name="hasSpecialFeature">Optional filter by items with special features. (optional)</param>
        /// <param name="hasTrailer">Optional filter by items with trailers. (optional)</param>
        /// <param name="adjacentTo">Optional. Return items that are siblings of a supplied item. (optional)</param>
        /// <param name="minIndexNumber">Optional filter by minimum index number. (optional)</param>
        /// <param name="minPlayers">Optional filter by minimum number of game players. (optional)</param>
        /// <param name="maxPlayers">Optional filter by maximum number of game players. (optional)</param>
        /// <param name="parentIndexNumber">Optional filter by parent index number. (optional)</param>
        /// <param name="hasParentalRating">Optional filter by items that have or do not have a parental rating (optional)</param>
        /// <param name="isHD">Optional filter by items that are HD or not. (optional)</param>
        /// <param name="locationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="excludeLocationTypes">Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="isMissing">Optional filter by items that are missing episodes or not. (optional)</param>
        /// <param name="isUnaired">Optional filter by items that are unaired episodes or not. (optional)</param>
        /// <param name="minCommunityRating">Optional filter by minimum community rating. (optional)</param>
        /// <param name="minCriticRating">Optional filter by minimum critic rating. (optional)</param>
        /// <param name="airedDuringSeason">Gets all episodes that aired during a season, including specials. (optional)</param>
        /// <param name="minPremiereDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSaved">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minDateLastSavedForUser">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxPremiereDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="hasOverview">Optional filter by items that have an overview or not. (optional)</param>
        /// <param name="hasImdbId">Optional filter by items that have an imdb id or not. (optional)</param>
        /// <param name="hasTmdbId">Optional filter by items that have a tmdb id or not. (optional)</param>
        /// <param name="hasTvdbId">Optional filter by items that have a tvdb id or not. (optional)</param>
        /// <param name="excludeItemIds">Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="recursive">When searching within folders, this determines whether or not the search will be recursive. true/false (optional)</param>
        /// <param name="searchTerm">Enter a search term to perform a search request (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="parentId">Specify this to localize the search to a specific item or folder. Omit to use the root (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <param name="excludeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="includeItemTypes">Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="anyProviderIdEquals">Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs. (optional)</param>
        /// <param name="filters">Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes (optional)</param>
        /// <param name="isFavorite">Optional filter by items that are marked as favorite, or not. (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="mediaTypes">Optional filter by MediaType. Allows multiple, comma delimited. (optional)</param>
        /// <param name="imageTypes">Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime (optional)</param>
        /// <param name="isPlayed">Optional filter by items that are played, or not. (optional)</param>
        /// <param name="genres">Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="officialRatings">Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="tags">Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="years">Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="person">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personIds">Optional. If specified, results will be filtered to include only those containing the specified person. (optional)</param>
        /// <param name="personTypes">Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited (optional)</param>
        /// <param name="studios">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="studioIds">Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artists">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="artistIds">Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="albums">Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted. (optional)</param>
        /// <param name="ids">Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited. (optional)</param>
        /// <param name="videoTypes">Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted. (optional)</param>
        /// <param name="containers">Optional filter by Container. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="audioCodecs">Optional filter by AudioCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="videoCodecs">Optional filter by VideoCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="subtitleCodecs">Optional filter by SubtitleCodec. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="path">Optional filter by Path. (optional)</param>
        /// <param name="userId">User Id (optional)</param>
        /// <param name="minOfficialRating">Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)</param>
        /// <param name="isLocked">Optional filter by items that are locked. (optional)</param>
        /// <param name="isPlaceHolder">Optional filter by items that are placeholders (optional)</param>
        /// <param name="hasOfficialRating">Optional filter by items that have official ratings (optional)</param>
        /// <param name="groupItemsIntoCollections">Whether or not to hide items behind their boxsets. (optional)</param>
        /// <param name="is3D">Optional filter by items that are 3D, or not. (optional)</param>
        /// <param name="seriesStatus">Optional filter by Series Status. Allows multiple, comma delimeted. (optional)</param>
        /// <param name="nameStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="artistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="albumArtistStartsWithOrGreater">Optional filter by items whose name is sorted equally or greater than a given input string. (optional)</param>
        /// <param name="nameStartsWith">Optional filter by items whose name is sorted equally than a given input string. (optional)</param>
        /// <param name="nameLessThan">Optional filter by items whose name is equally or lesser than a given input string. (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> GetLivetvRecordingsAsyncWithHttpInfo (string channelId, LiveTvRecordingStatus status, bool? isInProgress, string seriesTimerId, string artistType, string maxOfficialRating, bool? hasThemeSong, bool? hasThemeVideo, bool? hasSubtitles, bool? hasSpecialFeature, bool? hasTrailer, string adjacentTo, int? minIndexNumber, int? minPlayers, int? maxPlayers, int? parentIndexNumber, bool? hasParentalRating, bool? isHD, string locationTypes, string excludeLocationTypes, bool? isMissing, bool? isUnaired, double? minCommunityRating, double? minCriticRating, int? airedDuringSeason, string minPremiereDate, string minDateLastSaved, string minDateLastSavedForUser, string maxPremiereDate, bool? hasOverview, bool? hasImdbId, bool? hasTmdbId, bool? hasTvdbId, string excludeItemIds, int? startIndex, int? limit, bool? recursive, string searchTerm, string sortOrder, string parentId, string fields, string excludeItemTypes, string includeItemTypes, string anyProviderIdEquals, string filters, bool? isFavorite, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, string mediaTypes, string imageTypes, string sortBy, bool? isPlayed, string genres, string officialRatings, string tags, string years, bool? enableImages, bool? enableUserData, int? imageTypeLimit, string enableImageTypes, string person, string personIds, string personTypes, string studios, string studioIds, string artists, string artistIds, string albums, string ids, string videoTypes, string containers, string audioCodecs, string videoCodecs, string subtitleCodecs, string path, string userId, string minOfficialRating, bool? isLocked, bool? isPlaceHolder, bool? hasOfficialRating, bool? groupItemsIntoCollections, bool? is3D, string seriesStatus, string nameStartsWithOrGreater, string artistStartsWithOrGreater, string albumArtistStartsWithOrGreater, string nameStartsWith, string nameLessThan)
        {

            var localVarPath = "/LiveTv/Recordings";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (channelId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ChannelId", channelId)); // query parameter
            if (status != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Status", status)); // query parameter
            if (isInProgress != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsInProgress", isInProgress)); // query parameter
            if (seriesTimerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SeriesTimerId", seriesTimerId)); // query parameter
            if (artistType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ArtistType", artistType)); // query parameter
            if (maxOfficialRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxOfficialRating", maxOfficialRating)); // query parameter
            if (hasThemeSong != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasThemeSong", hasThemeSong)); // query parameter
            if (hasThemeVideo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasThemeVideo", hasThemeVideo)); // query parameter
            if (hasSubtitles != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasSubtitles", hasSubtitles)); // query parameter
            if (hasSpecialFeature != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasSpecialFeature", hasSpecialFeature)); // query parameter
            if (hasTrailer != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasTrailer", hasTrailer)); // query parameter
            if (adjacentTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AdjacentTo", adjacentTo)); // query parameter
            if (minIndexNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinIndexNumber", minIndexNumber)); // query parameter
            if (minPlayers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinPlayers", minPlayers)); // query parameter
            if (maxPlayers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxPlayers", maxPlayers)); // query parameter
            if (parentIndexNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ParentIndexNumber", parentIndexNumber)); // query parameter
            if (hasParentalRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasParentalRating", hasParentalRating)); // query parameter
            if (isHD != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsHD", isHD)); // query parameter
            if (locationTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "LocationTypes", locationTypes)); // query parameter
            if (excludeLocationTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ExcludeLocationTypes", excludeLocationTypes)); // query parameter
            if (isMissing != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsMissing", isMissing)); // query parameter
            if (isUnaired != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsUnaired", isUnaired)); // query parameter
            if (minCommunityRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinCommunityRating", minCommunityRating)); // query parameter
            if (minCriticRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinCriticRating", minCriticRating)); // query parameter
            if (airedDuringSeason != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AiredDuringSeason", airedDuringSeason)); // query parameter
            if (minPremiereDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinPremiereDate", minPremiereDate)); // query parameter
            if (minDateLastSaved != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinDateLastSaved", minDateLastSaved)); // query parameter
            if (minDateLastSavedForUser != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinDateLastSavedForUser", minDateLastSavedForUser)); // query parameter
            if (maxPremiereDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxPremiereDate", maxPremiereDate)); // query parameter
            if (hasOverview != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasOverview", hasOverview)); // query parameter
            if (hasImdbId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasImdbId", hasImdbId)); // query parameter
            if (hasTmdbId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasTmdbId", hasTmdbId)); // query parameter
            if (hasTvdbId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasTvdbId", hasTvdbId)); // query parameter
            if (excludeItemIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ExcludeItemIds", excludeItemIds)); // query parameter
            if (startIndex != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StartIndex", startIndex)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Limit", limit)); // query parameter
            if (recursive != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Recursive", recursive)); // query parameter
            if (searchTerm != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SearchTerm", searchTerm)); // query parameter
            if (sortOrder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortOrder", sortOrder)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ParentId", parentId)); // query parameter
            if (fields != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Fields", fields)); // query parameter
            if (excludeItemTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ExcludeItemTypes", excludeItemTypes)); // query parameter
            if (includeItemTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IncludeItemTypes", includeItemTypes)); // query parameter
            if (anyProviderIdEquals != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AnyProviderIdEquals", anyProviderIdEquals)); // query parameter
            if (filters != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Filters", filters)); // query parameter
            if (isFavorite != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsFavorite", isFavorite)); // query parameter
            if (isMovie != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsMovie", isMovie)); // query parameter
            if (isSeries != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSeries", isSeries)); // query parameter
            if (isNews != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsNews", isNews)); // query parameter
            if (isKids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsKids", isKids)); // query parameter
            if (isSports != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSports", isSports)); // query parameter
            if (mediaTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MediaTypes", mediaTypes)); // query parameter
            if (imageTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ImageTypes", imageTypes)); // query parameter
            if (sortBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortBy", sortBy)); // query parameter
            if (isPlayed != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsPlayed", isPlayed)); // query parameter
            if (genres != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Genres", genres)); // query parameter
            if (officialRatings != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "OfficialRatings", officialRatings)); // query parameter
            if (tags != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Tags", tags)); // query parameter
            if (years != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Years", years)); // query parameter
            if (enableImages != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImages", enableImages)); // query parameter
            if (enableUserData != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableUserData", enableUserData)); // query parameter
            if (imageTypeLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ImageTypeLimit", imageTypeLimit)); // query parameter
            if (enableImageTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImageTypes", enableImageTypes)); // query parameter
            if (person != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Person", person)); // query parameter
            if (personIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "PersonIds", personIds)); // query parameter
            if (personTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "PersonTypes", personTypes)); // query parameter
            if (studios != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Studios", studios)); // query parameter
            if (studioIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StudioIds", studioIds)); // query parameter
            if (artists != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Artists", artists)); // query parameter
            if (artistIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ArtistIds", artistIds)); // query parameter
            if (albums != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Albums", albums)); // query parameter
            if (ids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Ids", ids)); // query parameter
            if (videoTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "VideoTypes", videoTypes)); // query parameter
            if (containers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Containers", containers)); // query parameter
            if (audioCodecs != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AudioCodecs", audioCodecs)); // query parameter
            if (videoCodecs != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "VideoCodecs", videoCodecs)); // query parameter
            if (subtitleCodecs != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SubtitleCodecs", subtitleCodecs)); // query parameter
            if (path != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Path", path)); // query parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "UserId", userId)); // query parameter
            if (minOfficialRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinOfficialRating", minOfficialRating)); // query parameter
            if (isLocked != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsLocked", isLocked)); // query parameter
            if (isPlaceHolder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsPlaceHolder", isPlaceHolder)); // query parameter
            if (hasOfficialRating != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasOfficialRating", hasOfficialRating)); // query parameter
            if (groupItemsIntoCollections != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "GroupItemsIntoCollections", groupItemsIntoCollections)); // query parameter
            if (is3D != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Is3D", is3D)); // query parameter
            if (seriesStatus != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SeriesStatus", seriesStatus)); // query parameter
            if (nameStartsWithOrGreater != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "NameStartsWithOrGreater", nameStartsWithOrGreater)); // query parameter
            if (artistStartsWithOrGreater != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ArtistStartsWithOrGreater", artistStartsWithOrGreater)); // query parameter
            if (albumArtistStartsWithOrGreater != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "AlbumArtistStartsWithOrGreater", albumArtistStartsWithOrGreater)); // query parameter
            if (nameStartsWith != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "NameStartsWith", nameStartsWith)); // query parameter
            if (nameLessThan != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "NameLessThan", nameLessThan)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvRecordings", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Gets a live tv recording Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Recording Id</param>
        /// <param name="userId">Optional attach user data. (optional)</param>
        /// <returns>BaseItemDto</returns>
        public BaseItemDto GetLivetvRecordingsById (string id, string userId)
        {
             ApiResponse<BaseItemDto> localVarResponse = GetLivetvRecordingsByIdWithHttpInfo(id, userId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a live tv recording Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Recording Id</param>
        /// <param name="userId">Optional attach user data. (optional)</param>
        /// <returns>ApiResponse of BaseItemDto</returns>
        public ApiResponse< BaseItemDto > GetLivetvRecordingsByIdWithHttpInfo (string id, string userId)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->GetLivetvRecordingsById");

            var localVarPath = "/LiveTv/Recordings/{Id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "UserId", userId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvRecordingsById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BaseItemDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (BaseItemDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BaseItemDto)));
        }

        /// <summary>
        /// Gets a live tv recording Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Recording Id</param>
        /// <param name="userId">Optional attach user data. (optional)</param>
        /// <returns>Task of BaseItemDto</returns>
        public async System.Threading.Tasks.Task<BaseItemDto> GetLivetvRecordingsByIdAsync (string id, string userId)
        {
             ApiResponse<BaseItemDto> localVarResponse = await GetLivetvRecordingsByIdAsyncWithHttpInfo(id, userId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets a live tv recording Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Recording Id</param>
        /// <param name="userId">Optional attach user data. (optional)</param>
        /// <returns>Task of ApiResponse (BaseItemDto)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BaseItemDto>> GetLivetvRecordingsByIdAsyncWithHttpInfo (string id, string userId)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->GetLivetvRecordingsById");

            var localVarPath = "/LiveTv/Recordings/{Id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "UserId", userId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvRecordingsById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BaseItemDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (BaseItemDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BaseItemDto)));
        }

        /// <summary>
        /// Gets recording folders Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">Optional filter by user and attach user data. (optional)</param>
        /// <returns>List&lt;BaseItemDto&gt;</returns>
        public List<BaseItemDto> GetLivetvRecordingsFolders (string userId)
        {
             ApiResponse<List<BaseItemDto>> localVarResponse = GetLivetvRecordingsFoldersWithHttpInfo(userId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets recording folders Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">Optional filter by user and attach user data. (optional)</param>
        /// <returns>ApiResponse of List&lt;BaseItemDto&gt;</returns>
        public ApiResponse< List<BaseItemDto> > GetLivetvRecordingsFoldersWithHttpInfo (string userId)
        {

            var localVarPath = "/LiveTv/Recordings/Folders";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "UserId", userId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvRecordingsFolders", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<BaseItemDto>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<BaseItemDto>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<BaseItemDto>)));
        }

        /// <summary>
        /// Gets recording folders Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">Optional filter by user and attach user data. (optional)</param>
        /// <returns>Task of List&lt;BaseItemDto&gt;</returns>
        public async System.Threading.Tasks.Task<List<BaseItemDto>> GetLivetvRecordingsFoldersAsync (string userId)
        {
             ApiResponse<List<BaseItemDto>> localVarResponse = await GetLivetvRecordingsFoldersAsyncWithHttpInfo(userId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets recording folders Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">Optional filter by user and attach user data. (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;BaseItemDto&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<BaseItemDto>>> GetLivetvRecordingsFoldersAsyncWithHttpInfo (string userId)
        {

            var localVarPath = "/LiveTv/Recordings/Folders";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "UserId", userId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvRecordingsFolders", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<BaseItemDto>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<BaseItemDto>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<BaseItemDto>)));
        }

        /// <summary>
        /// Gets live tv recording groups Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>QueryResultBaseItemDto</returns>
        public QueryResultBaseItemDto GetLivetvRecordingsGroups ()
        {
             ApiResponse<QueryResultBaseItemDto> localVarResponse = GetLivetvRecordingsGroupsWithHttpInfo();
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets live tv recording groups Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of QueryResultBaseItemDto</returns>
        public ApiResponse< QueryResultBaseItemDto > GetLivetvRecordingsGroupsWithHttpInfo ()
        {

            var localVarPath = "/LiveTv/Recordings/Groups";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvRecordingsGroups", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultBaseItemDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultBaseItemDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultBaseItemDto)));
        }

        /// <summary>
        /// Gets live tv recording groups Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of QueryResultBaseItemDto</returns>
        public async System.Threading.Tasks.Task<QueryResultBaseItemDto> GetLivetvRecordingsGroupsAsync ()
        {
             ApiResponse<QueryResultBaseItemDto> localVarResponse = await GetLivetvRecordingsGroupsAsyncWithHttpInfo();
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets live tv recording groups Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (QueryResultBaseItemDto)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<QueryResultBaseItemDto>> GetLivetvRecordingsGroupsAsyncWithHttpInfo ()
        {

            var localVarPath = "/LiveTv/Recordings/Groups";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvRecordingsGroups", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultBaseItemDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultBaseItemDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultBaseItemDto)));
        }

        /// <summary>
        /// Gets live tv recordings Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>QueryResultBaseItemDto</returns>
        public QueryResultBaseItemDto GetLivetvRecordingsSeries ()
        {
             ApiResponse<QueryResultBaseItemDto> localVarResponse = GetLivetvRecordingsSeriesWithHttpInfo();
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets live tv recordings Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of QueryResultBaseItemDto</returns>
        public ApiResponse< QueryResultBaseItemDto > GetLivetvRecordingsSeriesWithHttpInfo ()
        {

            var localVarPath = "/LiveTv/Recordings/Series";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvRecordingsSeries", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultBaseItemDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultBaseItemDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultBaseItemDto)));
        }

        /// <summary>
        /// Gets live tv recordings Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of QueryResultBaseItemDto</returns>
        public async System.Threading.Tasks.Task<QueryResultBaseItemDto> GetLivetvRecordingsSeriesAsync ()
        {
             ApiResponse<QueryResultBaseItemDto> localVarResponse = await GetLivetvRecordingsSeriesAsyncWithHttpInfo();
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets live tv recordings Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (QueryResultBaseItemDto)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<QueryResultBaseItemDto>> GetLivetvRecordingsSeriesAsyncWithHttpInfo ()
        {

            var localVarPath = "/LiveTv/Recordings/Series";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvRecordingsSeries", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultBaseItemDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultBaseItemDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultBaseItemDto)));
        }

        /// <summary>
        /// Gets live tv series timers Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Optional. Sort by SortName or Priority (optional)</param>
        /// <param name="sortOrder">Optional. Sort in Ascending or Descending order (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <returns>QueryResultLiveTvSeriesTimerInfoDto</returns>
        public QueryResultLiveTvSeriesTimerInfoDto GetLivetvSeriestimers (string sortBy, SortOrder sortOrder, int? startIndex, int? limit)
        {
             ApiResponse<QueryResultLiveTvSeriesTimerInfoDto> localVarResponse = GetLivetvSeriestimersWithHttpInfo(sortBy, sortOrder, startIndex, limit);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets live tv series timers Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Optional. Sort by SortName or Priority (optional)</param>
        /// <param name="sortOrder">Optional. Sort in Ascending or Descending order (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <returns>ApiResponse of QueryResultLiveTvSeriesTimerInfoDto</returns>
        public ApiResponse< QueryResultLiveTvSeriesTimerInfoDto > GetLivetvSeriestimersWithHttpInfo (string sortBy, SortOrder sortOrder, int? startIndex, int? limit)
        {

            var localVarPath = "/LiveTv/SeriesTimers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (sortBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortBy", sortBy)); // query parameter
            if (sortOrder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortOrder", sortOrder)); // query parameter
            if (startIndex != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StartIndex", startIndex)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Limit", limit)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvSeriestimers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultLiveTvSeriesTimerInfoDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultLiveTvSeriesTimerInfoDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultLiveTvSeriesTimerInfoDto)));
        }

        /// <summary>
        /// Gets live tv series timers Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Optional. Sort by SortName or Priority (optional)</param>
        /// <param name="sortOrder">Optional. Sort in Ascending or Descending order (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <returns>Task of QueryResultLiveTvSeriesTimerInfoDto</returns>
        public async System.Threading.Tasks.Task<QueryResultLiveTvSeriesTimerInfoDto> GetLivetvSeriestimersAsync (string sortBy, SortOrder sortOrder, int? startIndex, int? limit)
        {
             ApiResponse<QueryResultLiveTvSeriesTimerInfoDto> localVarResponse = await GetLivetvSeriestimersAsyncWithHttpInfo(sortBy, sortOrder, startIndex, limit);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets live tv series timers Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Optional. Sort by SortName or Priority (optional)</param>
        /// <param name="sortOrder">Optional. Sort in Ascending or Descending order (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <returns>Task of ApiResponse (QueryResultLiveTvSeriesTimerInfoDto)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<QueryResultLiveTvSeriesTimerInfoDto>> GetLivetvSeriestimersAsyncWithHttpInfo (string sortBy, SortOrder sortOrder, int? startIndex, int? limit)
        {

            var localVarPath = "/LiveTv/SeriesTimers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (sortBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortBy", sortBy)); // query parameter
            if (sortOrder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortOrder", sortOrder)); // query parameter
            if (startIndex != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StartIndex", startIndex)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Limit", limit)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvSeriestimers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultLiveTvSeriesTimerInfoDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultLiveTvSeriesTimerInfoDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultLiveTvSeriesTimerInfoDto)));
        }

        /// <summary>
        /// Gets a live tv series timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>LiveTvTimerInfoDto</returns>
        public LiveTvTimerInfoDto GetLivetvSeriestimersById (string id)
        {
             ApiResponse<LiveTvTimerInfoDto> localVarResponse = GetLivetvSeriestimersByIdWithHttpInfo(id);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a live tv series timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>ApiResponse of LiveTvTimerInfoDto</returns>
        public ApiResponse< LiveTvTimerInfoDto > GetLivetvSeriestimersByIdWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->GetLivetvSeriestimersById");

            var localVarPath = "/LiveTv/SeriesTimers/{Id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvSeriestimersById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<LiveTvTimerInfoDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (LiveTvTimerInfoDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(LiveTvTimerInfoDto)));
        }

        /// <summary>
        /// Gets a live tv series timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>Task of LiveTvTimerInfoDto</returns>
        public async System.Threading.Tasks.Task<LiveTvTimerInfoDto> GetLivetvSeriestimersByIdAsync (string id)
        {
             ApiResponse<LiveTvTimerInfoDto> localVarResponse = await GetLivetvSeriestimersByIdAsyncWithHttpInfo(id);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets a live tv series timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>Task of ApiResponse (LiveTvTimerInfoDto)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<LiveTvTimerInfoDto>> GetLivetvSeriestimersByIdAsyncWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->GetLivetvSeriestimersById");

            var localVarPath = "/LiveTv/SeriesTimers/{Id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvSeriestimersById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<LiveTvTimerInfoDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (LiveTvTimerInfoDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(LiveTvTimerInfoDto)));
        }

        /// <summary>
        /// Gets live tv timers Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">Optional filter by channel id. (optional)</param>
        /// <param name="seriesTimerId">Optional filter by timers belonging to a series timer (optional)</param>
        /// <returns>QueryResultLiveTvTimerInfoDto</returns>
        public QueryResultLiveTvTimerInfoDto GetLivetvTimers (string channelId, string seriesTimerId)
        {
             ApiResponse<QueryResultLiveTvTimerInfoDto> localVarResponse = GetLivetvTimersWithHttpInfo(channelId, seriesTimerId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets live tv timers Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">Optional filter by channel id. (optional)</param>
        /// <param name="seriesTimerId">Optional filter by timers belonging to a series timer (optional)</param>
        /// <returns>ApiResponse of QueryResultLiveTvTimerInfoDto</returns>
        public ApiResponse< QueryResultLiveTvTimerInfoDto > GetLivetvTimersWithHttpInfo (string channelId, string seriesTimerId)
        {

            var localVarPath = "/LiveTv/Timers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (channelId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ChannelId", channelId)); // query parameter
            if (seriesTimerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SeriesTimerId", seriesTimerId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvTimers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultLiveTvTimerInfoDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultLiveTvTimerInfoDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultLiveTvTimerInfoDto)));
        }

        /// <summary>
        /// Gets live tv timers Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">Optional filter by channel id. (optional)</param>
        /// <param name="seriesTimerId">Optional filter by timers belonging to a series timer (optional)</param>
        /// <returns>Task of QueryResultLiveTvTimerInfoDto</returns>
        public async System.Threading.Tasks.Task<QueryResultLiveTvTimerInfoDto> GetLivetvTimersAsync (string channelId, string seriesTimerId)
        {
             ApiResponse<QueryResultLiveTvTimerInfoDto> localVarResponse = await GetLivetvTimersAsyncWithHttpInfo(channelId, seriesTimerId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets live tv timers Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">Optional filter by channel id. (optional)</param>
        /// <param name="seriesTimerId">Optional filter by timers belonging to a series timer (optional)</param>
        /// <returns>Task of ApiResponse (QueryResultLiveTvTimerInfoDto)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<QueryResultLiveTvTimerInfoDto>> GetLivetvTimersAsyncWithHttpInfo (string channelId, string seriesTimerId)
        {

            var localVarPath = "/LiveTv/Timers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (channelId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ChannelId", channelId)); // query parameter
            if (seriesTimerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SeriesTimerId", seriesTimerId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvTimers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultLiveTvTimerInfoDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultLiveTvTimerInfoDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultLiveTvTimerInfoDto)));
        }

        /// <summary>
        /// Gets a live tv timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>LiveTvTimerInfoDto</returns>
        public LiveTvTimerInfoDto GetLivetvTimersById (string id)
        {
             ApiResponse<LiveTvTimerInfoDto> localVarResponse = GetLivetvTimersByIdWithHttpInfo(id);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets a live tv timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>ApiResponse of LiveTvTimerInfoDto</returns>
        public ApiResponse< LiveTvTimerInfoDto > GetLivetvTimersByIdWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->GetLivetvTimersById");

            var localVarPath = "/LiveTv/Timers/{Id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvTimersById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<LiveTvTimerInfoDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (LiveTvTimerInfoDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(LiveTvTimerInfoDto)));
        }

        /// <summary>
        /// Gets a live tv timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>Task of LiveTvTimerInfoDto</returns>
        public async System.Threading.Tasks.Task<LiveTvTimerInfoDto> GetLivetvTimersByIdAsync (string id)
        {
             ApiResponse<LiveTvTimerInfoDto> localVarResponse = await GetLivetvTimersByIdAsyncWithHttpInfo(id);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets a live tv timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>Task of ApiResponse (LiveTvTimerInfoDto)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<LiveTvTimerInfoDto>> GetLivetvTimersByIdAsyncWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->GetLivetvTimersById");

            var localVarPath = "/LiveTv/Timers/{Id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvTimersById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<LiveTvTimerInfoDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (LiveTvTimerInfoDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(LiveTvTimerInfoDto)));
        }

        /// <summary>
        /// Gets default values for a new timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="programId">Optional, to attach default values based on a program. (optional)</param>
        /// <returns>LiveTvSeriesTimerInfoDto</returns>
        public LiveTvSeriesTimerInfoDto GetLivetvTimersDefaults (string programId)
        {
             ApiResponse<LiveTvSeriesTimerInfoDto> localVarResponse = GetLivetvTimersDefaultsWithHttpInfo(programId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets default values for a new timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="programId">Optional, to attach default values based on a program. (optional)</param>
        /// <returns>ApiResponse of LiveTvSeriesTimerInfoDto</returns>
        public ApiResponse< LiveTvSeriesTimerInfoDto > GetLivetvTimersDefaultsWithHttpInfo (string programId)
        {

            var localVarPath = "/LiveTv/Timers/Defaults";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (programId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ProgramId", programId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvTimersDefaults", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<LiveTvSeriesTimerInfoDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (LiveTvSeriesTimerInfoDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(LiveTvSeriesTimerInfoDto)));
        }

        /// <summary>
        /// Gets default values for a new timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="programId">Optional, to attach default values based on a program. (optional)</param>
        /// <returns>Task of LiveTvSeriesTimerInfoDto</returns>
        public async System.Threading.Tasks.Task<LiveTvSeriesTimerInfoDto> GetLivetvTimersDefaultsAsync (string programId)
        {
             ApiResponse<LiveTvSeriesTimerInfoDto> localVarResponse = await GetLivetvTimersDefaultsAsyncWithHttpInfo(programId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets default values for a new timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="programId">Optional, to attach default values based on a program. (optional)</param>
        /// <returns>Task of ApiResponse (LiveTvSeriesTimerInfoDto)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<LiveTvSeriesTimerInfoDto>> GetLivetvTimersDefaultsAsyncWithHttpInfo (string programId)
        {

            var localVarPath = "/LiveTv/Timers/Defaults";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (programId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ProgramId", programId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvTimersDefaults", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<LiveTvSeriesTimerInfoDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (LiveTvSeriesTimerInfoDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(LiveTvSeriesTimerInfoDto)));
        }

        /// <summary>
        /// Gets tuner hosts Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>List&lt;LiveTvTunerHostInfo&gt;</returns>
        public List<LiveTvTunerHostInfo> GetLivetvTunerhosts ()
        {
             ApiResponse<List<LiveTvTunerHostInfo>> localVarResponse = GetLivetvTunerhostsWithHttpInfo();
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets tuner hosts Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of List&lt;LiveTvTunerHostInfo&gt;</returns>
        public ApiResponse< List<LiveTvTunerHostInfo> > GetLivetvTunerhostsWithHttpInfo ()
        {

            var localVarPath = "/LiveTv/TunerHosts";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvTunerhosts", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<LiveTvTunerHostInfo>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<LiveTvTunerHostInfo>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<LiveTvTunerHostInfo>)));
        }

        /// <summary>
        /// Gets tuner hosts Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of List&lt;LiveTvTunerHostInfo&gt;</returns>
        public async System.Threading.Tasks.Task<List<LiveTvTunerHostInfo>> GetLivetvTunerhostsAsync ()
        {
             ApiResponse<List<LiveTvTunerHostInfo>> localVarResponse = await GetLivetvTunerhostsAsyncWithHttpInfo();
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets tuner hosts Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (List&lt;LiveTvTunerHostInfo&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<LiveTvTunerHostInfo>>> GetLivetvTunerhostsAsyncWithHttpInfo ()
        {

            var localVarPath = "/LiveTv/TunerHosts";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvTunerhosts", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<LiveTvTunerHostInfo>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<LiveTvTunerHostInfo>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<LiveTvTunerHostInfo>)));
        }

        /// <summary>
        /// Gets tuner hosts Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">Type</param>
        /// <returns>LiveTvTunerHostInfo</returns>
        public LiveTvTunerHostInfo GetLivetvTunerhostsDefaultByType (string type)
        {
             ApiResponse<LiveTvTunerHostInfo> localVarResponse = GetLivetvTunerhostsDefaultByTypeWithHttpInfo(type);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets tuner hosts Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">Type</param>
        /// <returns>ApiResponse of LiveTvTunerHostInfo</returns>
        public ApiResponse< LiveTvTunerHostInfo > GetLivetvTunerhostsDefaultByTypeWithHttpInfo (string type)
        {
            // verify the required parameter 'type' is set
            if (type == null)
                throw new ApiException(400, "Missing required parameter 'type' when calling LiveTvServiceApi->GetLivetvTunerhostsDefaultByType");

            var localVarPath = "/LiveTv/TunerHosts/Default/{Type}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (type != null) localVarPathParams.Add("Type", this.Configuration.ApiClient.ParameterToString(type)); // path parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvTunerhostsDefaultByType", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<LiveTvTunerHostInfo>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (LiveTvTunerHostInfo) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(LiveTvTunerHostInfo)));
        }

        /// <summary>
        /// Gets tuner hosts Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">Type</param>
        /// <returns>Task of LiveTvTunerHostInfo</returns>
        public async System.Threading.Tasks.Task<LiveTvTunerHostInfo> GetLivetvTunerhostsDefaultByTypeAsync (string type)
        {
             ApiResponse<LiveTvTunerHostInfo> localVarResponse = await GetLivetvTunerhostsDefaultByTypeAsyncWithHttpInfo(type);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets tuner hosts Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="type">Type</param>
        /// <returns>Task of ApiResponse (LiveTvTunerHostInfo)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<LiveTvTunerHostInfo>> GetLivetvTunerhostsDefaultByTypeAsyncWithHttpInfo (string type)
        {
            // verify the required parameter 'type' is set
            if (type == null)
                throw new ApiException(400, "Missing required parameter 'type' when calling LiveTvServiceApi->GetLivetvTunerhostsDefaultByType");

            var localVarPath = "/LiveTv/TunerHosts/Default/{Type}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (type != null) localVarPathParams.Add("Type", this.Configuration.ApiClient.ParameterToString(type)); // path parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvTunerhostsDefaultByType", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<LiveTvTunerHostInfo>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (LiveTvTunerHostInfo) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(LiveTvTunerHostInfo)));
        }

        /// <summary>
        ///  Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>List&lt;NameIdPair&gt;</returns>
        public List<NameIdPair> GetLivetvTunerhostsTypes ()
        {
             ApiResponse<List<NameIdPair>> localVarResponse = GetLivetvTunerhostsTypesWithHttpInfo();
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of List&lt;NameIdPair&gt;</returns>
        public ApiResponse< List<NameIdPair> > GetLivetvTunerhostsTypesWithHttpInfo ()
        {

            var localVarPath = "/LiveTv/TunerHosts/Types";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvTunerhostsTypes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<NameIdPair>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<NameIdPair>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<NameIdPair>)));
        }

        /// <summary>
        ///  Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of List&lt;NameIdPair&gt;</returns>
        public async System.Threading.Tasks.Task<List<NameIdPair>> GetLivetvTunerhostsTypesAsync ()
        {
             ApiResponse<List<NameIdPair>> localVarResponse = await GetLivetvTunerhostsTypesAsyncWithHttpInfo();
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (List&lt;NameIdPair&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<NameIdPair>>> GetLivetvTunerhostsTypesAsyncWithHttpInfo ()
        {

            var localVarPath = "/LiveTv/TunerHosts/Types";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvTunerhostsTypes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<NameIdPair>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<NameIdPair>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<NameIdPair>)));
        }

        /// <summary>
        ///  Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>List&lt;LiveTvTunerHostInfo&gt;</returns>
        public List<LiveTvTunerHostInfo> GetLivetvTunersDiscvover ()
        {
             ApiResponse<List<LiveTvTunerHostInfo>> localVarResponse = GetLivetvTunersDiscvoverWithHttpInfo();
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of List&lt;LiveTvTunerHostInfo&gt;</returns>
        public ApiResponse< List<LiveTvTunerHostInfo> > GetLivetvTunersDiscvoverWithHttpInfo ()
        {

            var localVarPath = "/LiveTv/Tuners/Discvover";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvTunersDiscvover", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<LiveTvTunerHostInfo>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<LiveTvTunerHostInfo>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<LiveTvTunerHostInfo>)));
        }

        /// <summary>
        ///  Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of List&lt;LiveTvTunerHostInfo&gt;</returns>
        public async System.Threading.Tasks.Task<List<LiveTvTunerHostInfo>> GetLivetvTunersDiscvoverAsync ()
        {
             ApiResponse<List<LiveTvTunerHostInfo>> localVarResponse = await GetLivetvTunersDiscvoverAsyncWithHttpInfo();
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (List&lt;LiveTvTunerHostInfo&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<LiveTvTunerHostInfo>>> GetLivetvTunersDiscvoverAsyncWithHttpInfo ()
        {

            var localVarPath = "/LiveTv/Tuners/Discvover";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLivetvTunersDiscvover", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<LiveTvTunerHostInfo>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<LiveTvTunerHostInfo>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<LiveTvTunerHostInfo>)));
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns></returns>
        public void HeadLivetvChannelmappingoptions (string providerId)
        {
             HeadLivetvChannelmappingoptionsWithHttpInfo(providerId);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> HeadLivetvChannelmappingoptionsWithHttpInfo (string providerId)
        {
            // verify the required parameter 'providerId' is set
            if (providerId == null)
                throw new ApiException(400, "Missing required parameter 'providerId' when calling LiveTvServiceApi->HeadLivetvChannelmappingoptions");

            var localVarPath = "/LiveTv/ChannelMappingOptions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (providerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ProviderId", providerId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("HeadLivetvChannelmappingoptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task HeadLivetvChannelmappingoptionsAsync (string providerId)
        {
             await HeadLivetvChannelmappingoptionsAsyncWithHttpInfo(providerId);

        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> HeadLivetvChannelmappingoptionsAsyncWithHttpInfo (string providerId)
        {
            // verify the required parameter 'providerId' is set
            if (providerId == null)
                throw new ApiException(400, "Missing required parameter 'providerId' when calling LiveTvServiceApi->HeadLivetvChannelmappingoptions");

            var localVarPath = "/LiveTv/ChannelMappingOptions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (providerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ProviderId", providerId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("HeadLivetvChannelmappingoptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns></returns>
        public void HeadLivetvChannelmappings (string providerId)
        {
             HeadLivetvChannelmappingsWithHttpInfo(providerId);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> HeadLivetvChannelmappingsWithHttpInfo (string providerId)
        {
            // verify the required parameter 'providerId' is set
            if (providerId == null)
                throw new ApiException(400, "Missing required parameter 'providerId' when calling LiveTvServiceApi->HeadLivetvChannelmappings");

            var localVarPath = "/LiveTv/ChannelMappings";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (providerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ProviderId", providerId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("HeadLivetvChannelmappings", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task HeadLivetvChannelmappingsAsync (string providerId)
        {
             await HeadLivetvChannelmappingsAsyncWithHttpInfo(providerId);

        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> HeadLivetvChannelmappingsAsyncWithHttpInfo (string providerId)
        {
            // verify the required parameter 'providerId' is set
            if (providerId == null)
                throw new ApiException(400, "Missing required parameter 'providerId' when calling LiveTvServiceApi->HeadLivetvChannelmappings");

            var localVarPath = "/LiveTv/ChannelMappings";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (providerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ProviderId", providerId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.HEAD, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("HeadLivetvChannelmappings", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns></returns>
        public void PostLivetvChannelmappingoptions (string providerId)
        {
             PostLivetvChannelmappingoptionsWithHttpInfo(providerId);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> PostLivetvChannelmappingoptionsWithHttpInfo (string providerId)
        {
            // verify the required parameter 'providerId' is set
            if (providerId == null)
                throw new ApiException(400, "Missing required parameter 'providerId' when calling LiveTvServiceApi->PostLivetvChannelmappingoptions");

            var localVarPath = "/LiveTv/ChannelMappingOptions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (providerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ProviderId", providerId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvChannelmappingoptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task PostLivetvChannelmappingoptionsAsync (string providerId)
        {
             await PostLivetvChannelmappingoptionsAsyncWithHttpInfo(providerId);

        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> PostLivetvChannelmappingoptionsAsyncWithHttpInfo (string providerId)
        {
            // verify the required parameter 'providerId' is set
            if (providerId == null)
                throw new ApiException(400, "Missing required parameter 'providerId' when calling LiveTvServiceApi->PostLivetvChannelmappingoptions");

            var localVarPath = "/LiveTv/ChannelMappingOptions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (providerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ProviderId", providerId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvChannelmappingoptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelMapping</param>
        /// <param name="providerId">Provider id</param>
        /// <returns></returns>
        public void PostLivetvChannelmappings (LiveTVApiSetChannelMapping body, string providerId)
        {
             PostLivetvChannelmappingsWithHttpInfo(body, providerId);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelMapping</param>
        /// <param name="providerId">Provider id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> PostLivetvChannelmappingsWithHttpInfo (LiveTVApiSetChannelMapping body, string providerId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling LiveTvServiceApi->PostLivetvChannelmappings");
            // verify the required parameter 'providerId' is set
            if (providerId == null)
                throw new ApiException(400, "Missing required parameter 'providerId' when calling LiveTvServiceApi->PostLivetvChannelmappings");

            var localVarPath = "/LiveTv/ChannelMappings";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/xml"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (providerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ProviderId", providerId)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvChannelmappings", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelMapping</param>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task PostLivetvChannelmappingsAsync (LiveTVApiSetChannelMapping body, string providerId)
        {
             await PostLivetvChannelmappingsAsyncWithHttpInfo(body, providerId);

        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelMapping</param>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> PostLivetvChannelmappingsAsyncWithHttpInfo (LiveTVApiSetChannelMapping body, string providerId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling LiveTvServiceApi->PostLivetvChannelmappings");
            // verify the required parameter 'providerId' is set
            if (providerId == null)
                throw new ApiException(400, "Missing required parameter 'providerId' when calling LiveTvServiceApi->PostLivetvChannelmappings");

            var localVarPath = "/LiveTv/ChannelMappings";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/xml"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (providerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ProviderId", providerId)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvChannelmappings", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Adds a listing provider Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">ListingsProviderInfo: </param>
        /// <returns>LiveTvListingsProviderInfo</returns>
        public LiveTvListingsProviderInfo PostLivetvListingproviders (LiveTvListingsProviderInfo body)
        {
             ApiResponse<LiveTvListingsProviderInfo> localVarResponse = PostLivetvListingprovidersWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Adds a listing provider Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">ListingsProviderInfo: </param>
        /// <returns>ApiResponse of LiveTvListingsProviderInfo</returns>
        public ApiResponse< LiveTvListingsProviderInfo > PostLivetvListingprovidersWithHttpInfo (LiveTvListingsProviderInfo body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling LiveTvServiceApi->PostLivetvListingproviders");

            var localVarPath = "/LiveTv/ListingProviders";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/xml"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvListingproviders", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<LiveTvListingsProviderInfo>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (LiveTvListingsProviderInfo) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(LiveTvListingsProviderInfo)));
        }

        /// <summary>
        /// Adds a listing provider Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">ListingsProviderInfo: </param>
        /// <returns>Task of LiveTvListingsProviderInfo</returns>
        public async System.Threading.Tasks.Task<LiveTvListingsProviderInfo> PostLivetvListingprovidersAsync (LiveTvListingsProviderInfo body)
        {
             ApiResponse<LiveTvListingsProviderInfo> localVarResponse = await PostLivetvListingprovidersAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Adds a listing provider Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">ListingsProviderInfo: </param>
        /// <returns>Task of ApiResponse (LiveTvListingsProviderInfo)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<LiveTvListingsProviderInfo>> PostLivetvListingprovidersAsyncWithHttpInfo (LiveTvListingsProviderInfo body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling LiveTvServiceApi->PostLivetvListingproviders");

            var localVarPath = "/LiveTv/ListingProviders";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/xml"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvListingproviders", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<LiveTvListingsProviderInfo>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (LiveTvListingsProviderInfo) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(LiveTvListingsProviderInfo)));
        }

        /// <summary>
        /// Deletes a listing provider Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Provider id (optional)</param>
        /// <returns></returns>
        public void PostLivetvListingprovidersDelete (string id)
        {
             PostLivetvListingprovidersDeleteWithHttpInfo(id);
        }

        /// <summary>
        /// Deletes a listing provider Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Provider id (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> PostLivetvListingprovidersDeleteWithHttpInfo (string id)
        {

            var localVarPath = "/LiveTv/ListingProviders/Delete";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Id", id)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvListingprovidersDelete", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Deletes a listing provider Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Provider id (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task PostLivetvListingprovidersDeleteAsync (string id)
        {
             await PostLivetvListingprovidersDeleteAsyncWithHttpInfo(id);

        }

        /// <summary>
        /// Deletes a listing provider Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Provider id (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> PostLivetvListingprovidersDeleteAsyncWithHttpInfo (string id)
        {

            var localVarPath = "/LiveTv/ListingProviders/Delete";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Id", id)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvListingprovidersDelete", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Sets a channel disabled or not Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelDisabled</param>
        /// <param name="id"></param>
        /// <returns>QueryResultEmbyLiveTVChannelManagementInfo</returns>
        public QueryResultEmbyLiveTVChannelManagementInfo PostLivetvManageChannelsByIdDisabled (LiveTVApiSetChannelDisabled body, string id)
        {
             ApiResponse<QueryResultEmbyLiveTVChannelManagementInfo> localVarResponse = PostLivetvManageChannelsByIdDisabledWithHttpInfo(body, id);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Sets a channel disabled or not Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelDisabled</param>
        /// <param name="id"></param>
        /// <returns>ApiResponse of QueryResultEmbyLiveTVChannelManagementInfo</returns>
        public ApiResponse< QueryResultEmbyLiveTVChannelManagementInfo > PostLivetvManageChannelsByIdDisabledWithHttpInfo (LiveTVApiSetChannelDisabled body, string id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling LiveTvServiceApi->PostLivetvManageChannelsByIdDisabled");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->PostLivetvManageChannelsByIdDisabled");

            var localVarPath = "/LiveTv/Manage/Channels/{Id}/Disabled";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/xml"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvManageChannelsByIdDisabled", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultEmbyLiveTVChannelManagementInfo>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultEmbyLiveTVChannelManagementInfo) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultEmbyLiveTVChannelManagementInfo)));
        }

        /// <summary>
        /// Sets a channel disabled or not Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelDisabled</param>
        /// <param name="id"></param>
        /// <returns>Task of QueryResultEmbyLiveTVChannelManagementInfo</returns>
        public async System.Threading.Tasks.Task<QueryResultEmbyLiveTVChannelManagementInfo> PostLivetvManageChannelsByIdDisabledAsync (LiveTVApiSetChannelDisabled body, string id)
        {
             ApiResponse<QueryResultEmbyLiveTVChannelManagementInfo> localVarResponse = await PostLivetvManageChannelsByIdDisabledAsyncWithHttpInfo(body, id);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Sets a channel disabled or not Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelDisabled</param>
        /// <param name="id"></param>
        /// <returns>Task of ApiResponse (QueryResultEmbyLiveTVChannelManagementInfo)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<QueryResultEmbyLiveTVChannelManagementInfo>> PostLivetvManageChannelsByIdDisabledAsyncWithHttpInfo (LiveTVApiSetChannelDisabled body, string id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling LiveTvServiceApi->PostLivetvManageChannelsByIdDisabled");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->PostLivetvManageChannelsByIdDisabled");

            var localVarPath = "/LiveTv/Manage/Channels/{Id}/Disabled";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/xml"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvManageChannelsByIdDisabled", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultEmbyLiveTVChannelManagementInfo>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultEmbyLiveTVChannelManagementInfo) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultEmbyLiveTVChannelManagementInfo)));
        }

        /// <summary>
        /// Sets a channel sort index Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelSortIndex</param>
        /// <param name="id"></param>
        /// <returns>QueryResultEmbyLiveTVChannelManagementInfo</returns>
        public QueryResultEmbyLiveTVChannelManagementInfo PostLivetvManageChannelsByIdSortindex (LiveTVApiSetChannelSortIndex body, string id)
        {
             ApiResponse<QueryResultEmbyLiveTVChannelManagementInfo> localVarResponse = PostLivetvManageChannelsByIdSortindexWithHttpInfo(body, id);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Sets a channel sort index Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelSortIndex</param>
        /// <param name="id"></param>
        /// <returns>ApiResponse of QueryResultEmbyLiveTVChannelManagementInfo</returns>
        public ApiResponse< QueryResultEmbyLiveTVChannelManagementInfo > PostLivetvManageChannelsByIdSortindexWithHttpInfo (LiveTVApiSetChannelSortIndex body, string id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling LiveTvServiceApi->PostLivetvManageChannelsByIdSortindex");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->PostLivetvManageChannelsByIdSortindex");

            var localVarPath = "/LiveTv/Manage/Channels/{Id}/SortIndex";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/xml"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvManageChannelsByIdSortindex", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultEmbyLiveTVChannelManagementInfo>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultEmbyLiveTVChannelManagementInfo) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultEmbyLiveTVChannelManagementInfo)));
        }

        /// <summary>
        /// Sets a channel sort index Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelSortIndex</param>
        /// <param name="id"></param>
        /// <returns>Task of QueryResultEmbyLiveTVChannelManagementInfo</returns>
        public async System.Threading.Tasks.Task<QueryResultEmbyLiveTVChannelManagementInfo> PostLivetvManageChannelsByIdSortindexAsync (LiveTVApiSetChannelSortIndex body, string id)
        {
             ApiResponse<QueryResultEmbyLiveTVChannelManagementInfo> localVarResponse = await PostLivetvManageChannelsByIdSortindexAsyncWithHttpInfo(body, id);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Sets a channel sort index Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelSortIndex</param>
        /// <param name="id"></param>
        /// <returns>Task of ApiResponse (QueryResultEmbyLiveTVChannelManagementInfo)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<QueryResultEmbyLiveTVChannelManagementInfo>> PostLivetvManageChannelsByIdSortindexAsyncWithHttpInfo (LiveTVApiSetChannelSortIndex body, string id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling LiveTvServiceApi->PostLivetvManageChannelsByIdSortindex");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->PostLivetvManageChannelsByIdSortindex");

            var localVarPath = "/LiveTv/Manage/Channels/{Id}/SortIndex";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/xml"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvManageChannelsByIdSortindex", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultEmbyLiveTVChannelManagementInfo>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultEmbyLiveTVChannelManagementInfo) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultEmbyLiveTVChannelManagementInfo)));
        }

        /// <summary>
        /// Gets available live tv epgs.. Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">GetPrograms</param>
        /// <param name="channelIds">The channels to return guide information for. (optional)</param>
        /// <param name="userId">Optional filter by user id. (optional)</param>
        /// <param name="hasAired">Optional. Filter by programs that have completed airing, or not. (optional)</param>
        /// <param name="minStartDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxStartDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minEndDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxEndDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <returns>QueryResultBaseItemDto</returns>
        public QueryResultBaseItemDto PostLivetvPrograms (LiveTVApiGetPrograms body, string channelIds, string userId, bool? hasAired, string minStartDate, string maxStartDate, string minEndDate, string maxEndDate, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, int? startIndex, int? limit, string sortBy, string sortOrder, string genreIds, bool? enableImages, int? imageTypeLimit, string enableImageTypes, bool? enableUserData, string fields)
        {
             ApiResponse<QueryResultBaseItemDto> localVarResponse = PostLivetvProgramsWithHttpInfo(body, channelIds, userId, hasAired, minStartDate, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, startIndex, limit, sortBy, sortOrder, genreIds, enableImages, imageTypeLimit, enableImageTypes, enableUserData, fields);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets available live tv epgs.. Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">GetPrograms</param>
        /// <param name="channelIds">The channels to return guide information for. (optional)</param>
        /// <param name="userId">Optional filter by user id. (optional)</param>
        /// <param name="hasAired">Optional. Filter by programs that have completed airing, or not. (optional)</param>
        /// <param name="minStartDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxStartDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minEndDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxEndDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <returns>ApiResponse of QueryResultBaseItemDto</returns>
        public ApiResponse< QueryResultBaseItemDto > PostLivetvProgramsWithHttpInfo (LiveTVApiGetPrograms body, string channelIds, string userId, bool? hasAired, string minStartDate, string maxStartDate, string minEndDate, string maxEndDate, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, int? startIndex, int? limit, string sortBy, string sortOrder, string genreIds, bool? enableImages, int? imageTypeLimit, string enableImageTypes, bool? enableUserData, string fields)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling LiveTvServiceApi->PostLivetvPrograms");

            var localVarPath = "/LiveTv/Programs";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/xml"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (channelIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ChannelIds", channelIds)); // query parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "UserId", userId)); // query parameter
            if (hasAired != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasAired", hasAired)); // query parameter
            if (minStartDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinStartDate", minStartDate)); // query parameter
            if (maxStartDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxStartDate", maxStartDate)); // query parameter
            if (minEndDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinEndDate", minEndDate)); // query parameter
            if (maxEndDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxEndDate", maxEndDate)); // query parameter
            if (isMovie != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsMovie", isMovie)); // query parameter
            if (isSeries != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSeries", isSeries)); // query parameter
            if (isNews != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsNews", isNews)); // query parameter
            if (isKids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsKids", isKids)); // query parameter
            if (isSports != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSports", isSports)); // query parameter
            if (startIndex != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StartIndex", startIndex)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Limit", limit)); // query parameter
            if (sortBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortBy", sortBy)); // query parameter
            if (sortOrder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortOrder", sortOrder)); // query parameter
            if (genreIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "GenreIds", genreIds)); // query parameter
            if (enableImages != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImages", enableImages)); // query parameter
            if (imageTypeLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ImageTypeLimit", imageTypeLimit)); // query parameter
            if (enableImageTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImageTypes", enableImageTypes)); // query parameter
            if (enableUserData != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableUserData", enableUserData)); // query parameter
            if (fields != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Fields", fields)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvPrograms", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultBaseItemDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultBaseItemDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultBaseItemDto)));
        }

        /// <summary>
        /// Gets available live tv epgs.. Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">GetPrograms</param>
        /// <param name="channelIds">The channels to return guide information for. (optional)</param>
        /// <param name="userId">Optional filter by user id. (optional)</param>
        /// <param name="hasAired">Optional. Filter by programs that have completed airing, or not. (optional)</param>
        /// <param name="minStartDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxStartDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minEndDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxEndDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <returns>Task of QueryResultBaseItemDto</returns>
        public async System.Threading.Tasks.Task<QueryResultBaseItemDto> PostLivetvProgramsAsync (LiveTVApiGetPrograms body, string channelIds, string userId, bool? hasAired, string minStartDate, string maxStartDate, string minEndDate, string maxEndDate, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, int? startIndex, int? limit, string sortBy, string sortOrder, string genreIds, bool? enableImages, int? imageTypeLimit, string enableImageTypes, bool? enableUserData, string fields)
        {
             ApiResponse<QueryResultBaseItemDto> localVarResponse = await PostLivetvProgramsAsyncWithHttpInfo(body, channelIds, userId, hasAired, minStartDate, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, startIndex, limit, sortBy, sortOrder, genreIds, enableImages, imageTypeLimit, enableImageTypes, enableUserData, fields);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets available live tv epgs.. Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">GetPrograms</param>
        /// <param name="channelIds">The channels to return guide information for. (optional)</param>
        /// <param name="userId">Optional filter by user id. (optional)</param>
        /// <param name="hasAired">Optional. Filter by programs that have completed airing, or not. (optional)</param>
        /// <param name="minStartDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxStartDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="minEndDate">Optional. The minimum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="maxEndDate">Optional. The maximum premiere date. Format &#x3D; ISO (optional)</param>
        /// <param name="isMovie">Optional filter for movies. (optional)</param>
        /// <param name="isSeries">Optional filter for series. (optional)</param>
        /// <param name="isNews">Optional filter for news. (optional)</param>
        /// <param name="isKids">Optional filter for kids. (optional)</param>
        /// <param name="isSports">Optional filter for sports. (optional)</param>
        /// <param name="startIndex">Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)</param>
        /// <param name="limit">Optional. The maximum number of records to return (optional)</param>
        /// <param name="sortBy">Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate (optional)</param>
        /// <param name="sortOrder">Sort Order - Ascending,Descending (optional)</param>
        /// <param name="genreIds">The genres to return guide information for. (optional)</param>
        /// <param name="enableImages">Optional, include image information in output (optional)</param>
        /// <param name="imageTypeLimit">Optional, the max number of images to return, per image type (optional)</param>
        /// <param name="enableImageTypes">Optional. The image types to include in the output. (optional)</param>
        /// <param name="enableUserData">Optional, include user data (optional)</param>
        /// <param name="fields">Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines (optional)</param>
        /// <returns>Task of ApiResponse (QueryResultBaseItemDto)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<QueryResultBaseItemDto>> PostLivetvProgramsAsyncWithHttpInfo (LiveTVApiGetPrograms body, string channelIds, string userId, bool? hasAired, string minStartDate, string maxStartDate, string minEndDate, string maxEndDate, bool? isMovie, bool? isSeries, bool? isNews, bool? isKids, bool? isSports, int? startIndex, int? limit, string sortBy, string sortOrder, string genreIds, bool? enableImages, int? imageTypeLimit, string enableImageTypes, bool? enableUserData, string fields)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling LiveTvServiceApi->PostLivetvPrograms");

            var localVarPath = "/LiveTv/Programs";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/xml"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (channelIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ChannelIds", channelIds)); // query parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "UserId", userId)); // query parameter
            if (hasAired != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "HasAired", hasAired)); // query parameter
            if (minStartDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinStartDate", minStartDate)); // query parameter
            if (maxStartDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxStartDate", maxStartDate)); // query parameter
            if (minEndDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MinEndDate", minEndDate)); // query parameter
            if (maxEndDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "MaxEndDate", maxEndDate)); // query parameter
            if (isMovie != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsMovie", isMovie)); // query parameter
            if (isSeries != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSeries", isSeries)); // query parameter
            if (isNews != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsNews", isNews)); // query parameter
            if (isKids != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsKids", isKids)); // query parameter
            if (isSports != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "IsSports", isSports)); // query parameter
            if (startIndex != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "StartIndex", startIndex)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Limit", limit)); // query parameter
            if (sortBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortBy", sortBy)); // query parameter
            if (sortOrder != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "SortOrder", sortOrder)); // query parameter
            if (genreIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "GenreIds", genreIds)); // query parameter
            if (enableImages != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImages", enableImages)); // query parameter
            if (imageTypeLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ImageTypeLimit", imageTypeLimit)); // query parameter
            if (enableImageTypes != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableImageTypes", enableImageTypes)); // query parameter
            if (enableUserData != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "EnableUserData", enableUserData)); // query parameter
            if (fields != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Fields", fields)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvPrograms", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QueryResultBaseItemDto>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (QueryResultBaseItemDto) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(QueryResultBaseItemDto)));
        }

        /// <summary>
        /// Deletes a live tv recording Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Recording Id</param>
        /// <returns></returns>
        public void PostLivetvRecordingsByIdDelete (string id)
        {
             PostLivetvRecordingsByIdDeleteWithHttpInfo(id);
        }

        /// <summary>
        /// Deletes a live tv recording Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Recording Id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> PostLivetvRecordingsByIdDeleteWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->PostLivetvRecordingsByIdDelete");

            var localVarPath = "/LiveTv/Recordings/{Id}/Delete";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvRecordingsByIdDelete", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Deletes a live tv recording Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Recording Id</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task PostLivetvRecordingsByIdDeleteAsync (string id)
        {
             await PostLivetvRecordingsByIdDeleteAsyncWithHttpInfo(id);

        }

        /// <summary>
        /// Deletes a live tv recording Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Recording Id</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> PostLivetvRecordingsByIdDeleteAsyncWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->PostLivetvRecordingsByIdDelete");

            var localVarPath = "/LiveTv/Recordings/{Id}/Delete";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvRecordingsByIdDelete", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Creates a live tv series timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SeriesTimerInfo: </param>
        /// <returns></returns>
        public void PostLivetvSeriestimers (LiveTvSeriesTimerInfo body)
        {
             PostLivetvSeriestimersWithHttpInfo(body);
        }

        /// <summary>
        /// Creates a live tv series timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SeriesTimerInfo: </param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> PostLivetvSeriestimersWithHttpInfo (LiveTvSeriesTimerInfo body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling LiveTvServiceApi->PostLivetvSeriestimers");

            var localVarPath = "/LiveTv/SeriesTimers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/xml"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvSeriestimers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Creates a live tv series timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SeriesTimerInfo: </param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task PostLivetvSeriestimersAsync (LiveTvSeriesTimerInfo body)
        {
             await PostLivetvSeriestimersAsyncWithHttpInfo(body);

        }

        /// <summary>
        /// Creates a live tv series timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SeriesTimerInfo: </param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> PostLivetvSeriestimersAsyncWithHttpInfo (LiveTvSeriesTimerInfo body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling LiveTvServiceApi->PostLivetvSeriestimers");

            var localVarPath = "/LiveTv/SeriesTimers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/xml"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvSeriestimers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Updates a live tv series timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SeriesTimerInfo: </param>
        /// <param name="id"></param>
        /// <returns></returns>
        public void PostLivetvSeriestimersById (LiveTvSeriesTimerInfo body, string id)
        {
             PostLivetvSeriestimersByIdWithHttpInfo(body, id);
        }

        /// <summary>
        /// Updates a live tv series timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SeriesTimerInfo: </param>
        /// <param name="id"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> PostLivetvSeriestimersByIdWithHttpInfo (LiveTvSeriesTimerInfo body, string id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling LiveTvServiceApi->PostLivetvSeriestimersById");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->PostLivetvSeriestimersById");

            var localVarPath = "/LiveTv/SeriesTimers/{Id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/xml"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvSeriestimersById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Updates a live tv series timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SeriesTimerInfo: </param>
        /// <param name="id"></param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task PostLivetvSeriestimersByIdAsync (LiveTvSeriesTimerInfo body, string id)
        {
             await PostLivetvSeriestimersByIdAsyncWithHttpInfo(body, id);

        }

        /// <summary>
        /// Updates a live tv series timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SeriesTimerInfo: </param>
        /// <param name="id"></param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> PostLivetvSeriestimersByIdAsyncWithHttpInfo (LiveTvSeriesTimerInfo body, string id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling LiveTvServiceApi->PostLivetvSeriestimersById");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->PostLivetvSeriestimersById");

            var localVarPath = "/LiveTv/SeriesTimers/{Id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/xml"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvSeriestimersById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Cancels a live tv series timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns></returns>
        public void PostLivetvSeriestimersByIdDelete (string id)
        {
             PostLivetvSeriestimersByIdDeleteWithHttpInfo(id);
        }

        /// <summary>
        /// Cancels a live tv series timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> PostLivetvSeriestimersByIdDeleteWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->PostLivetvSeriestimersByIdDelete");

            var localVarPath = "/LiveTv/SeriesTimers/{Id}/Delete";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvSeriestimersByIdDelete", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Cancels a live tv series timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task PostLivetvSeriestimersByIdDeleteAsync (string id)
        {
             await PostLivetvSeriestimersByIdDeleteAsyncWithHttpInfo(id);

        }

        /// <summary>
        /// Cancels a live tv series timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> PostLivetvSeriestimersByIdDeleteAsyncWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->PostLivetvSeriestimersByIdDelete");

            var localVarPath = "/LiveTv/SeriesTimers/{Id}/Delete";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvSeriestimersByIdDelete", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Creates a live tv timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">TimerInfoDto: </param>
        /// <returns></returns>
        public void PostLivetvTimers (LiveTvTimerInfoDto body)
        {
             PostLivetvTimersWithHttpInfo(body);
        }

        /// <summary>
        /// Creates a live tv timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">TimerInfoDto: </param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> PostLivetvTimersWithHttpInfo (LiveTvTimerInfoDto body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling LiveTvServiceApi->PostLivetvTimers");

            var localVarPath = "/LiveTv/Timers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/xml"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvTimers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Creates a live tv timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">TimerInfoDto: </param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task PostLivetvTimersAsync (LiveTvTimerInfoDto body)
        {
             await PostLivetvTimersAsyncWithHttpInfo(body);

        }

        /// <summary>
        /// Creates a live tv timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">TimerInfoDto: </param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> PostLivetvTimersAsyncWithHttpInfo (LiveTvTimerInfoDto body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling LiveTvServiceApi->PostLivetvTimers");

            var localVarPath = "/LiveTv/Timers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/xml"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvTimers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Updates a live tv timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">TimerInfoDto: </param>
        /// <param name="id"></param>
        /// <returns></returns>
        public void PostLivetvTimersById (LiveTvTimerInfoDto body, string id)
        {
             PostLivetvTimersByIdWithHttpInfo(body, id);
        }

        /// <summary>
        /// Updates a live tv timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">TimerInfoDto: </param>
        /// <param name="id"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> PostLivetvTimersByIdWithHttpInfo (LiveTvTimerInfoDto body, string id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling LiveTvServiceApi->PostLivetvTimersById");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->PostLivetvTimersById");

            var localVarPath = "/LiveTv/Timers/{Id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/xml"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvTimersById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Updates a live tv timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">TimerInfoDto: </param>
        /// <param name="id"></param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task PostLivetvTimersByIdAsync (LiveTvTimerInfoDto body, string id)
        {
             await PostLivetvTimersByIdAsyncWithHttpInfo(body, id);

        }

        /// <summary>
        /// Updates a live tv timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">TimerInfoDto: </param>
        /// <param name="id"></param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> PostLivetvTimersByIdAsyncWithHttpInfo (LiveTvTimerInfoDto body, string id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling LiveTvServiceApi->PostLivetvTimersById");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->PostLivetvTimersById");

            var localVarPath = "/LiveTv/Timers/{Id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/xml"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvTimersById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Cancels a live tv timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns></returns>
        public void PostLivetvTimersByIdDelete (string id)
        {
             PostLivetvTimersByIdDeleteWithHttpInfo(id);
        }

        /// <summary>
        /// Cancels a live tv timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> PostLivetvTimersByIdDeleteWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->PostLivetvTimersByIdDelete");

            var localVarPath = "/LiveTv/Timers/{Id}/Delete";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvTimersByIdDelete", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Cancels a live tv timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task PostLivetvTimersByIdDeleteAsync (string id)
        {
             await PostLivetvTimersByIdDeleteAsyncWithHttpInfo(id);

        }

        /// <summary>
        /// Cancels a live tv timer Requires authentication as user
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Timer Id</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> PostLivetvTimersByIdDeleteAsyncWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->PostLivetvTimersByIdDelete");

            var localVarPath = "/LiveTv/Timers/{Id}/Delete";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvTimersByIdDelete", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Adds a tuner host Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">TunerHostInfo: </param>
        /// <returns>LiveTvTunerHostInfo</returns>
        public LiveTvTunerHostInfo PostLivetvTunerhosts (LiveTvTunerHostInfo body)
        {
             ApiResponse<LiveTvTunerHostInfo> localVarResponse = PostLivetvTunerhostsWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Adds a tuner host Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">TunerHostInfo: </param>
        /// <returns>ApiResponse of LiveTvTunerHostInfo</returns>
        public ApiResponse< LiveTvTunerHostInfo > PostLivetvTunerhostsWithHttpInfo (LiveTvTunerHostInfo body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling LiveTvServiceApi->PostLivetvTunerhosts");

            var localVarPath = "/LiveTv/TunerHosts";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/xml"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvTunerhosts", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<LiveTvTunerHostInfo>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (LiveTvTunerHostInfo) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(LiveTvTunerHostInfo)));
        }

        /// <summary>
        /// Adds a tuner host Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">TunerHostInfo: </param>
        /// <returns>Task of LiveTvTunerHostInfo</returns>
        public async System.Threading.Tasks.Task<LiveTvTunerHostInfo> PostLivetvTunerhostsAsync (LiveTvTunerHostInfo body)
        {
             ApiResponse<LiveTvTunerHostInfo> localVarResponse = await PostLivetvTunerhostsAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Adds a tuner host Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">TunerHostInfo: </param>
        /// <returns>Task of ApiResponse (LiveTvTunerHostInfo)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<LiveTvTunerHostInfo>> PostLivetvTunerhostsAsyncWithHttpInfo (LiveTvTunerHostInfo body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling LiveTvServiceApi->PostLivetvTunerhosts");

            var localVarPath = "/LiveTv/TunerHosts";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/xml"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/xml"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvTunerhosts", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<LiveTvTunerHostInfo>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (LiveTvTunerHostInfo) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(LiveTvTunerHostInfo)));
        }

        /// <summary>
        /// Deletes a tuner host Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Tuner host id (optional)</param>
        /// <returns></returns>
        public void PostLivetvTunerhostsDelete (string id)
        {
             PostLivetvTunerhostsDeleteWithHttpInfo(id);
        }

        /// <summary>
        /// Deletes a tuner host Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Tuner host id (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> PostLivetvTunerhostsDeleteWithHttpInfo (string id)
        {

            var localVarPath = "/LiveTv/TunerHosts/Delete";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Id", id)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvTunerhostsDelete", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Deletes a tuner host Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Tuner host id (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task PostLivetvTunerhostsDeleteAsync (string id)
        {
             await PostLivetvTunerhostsDeleteAsyncWithHttpInfo(id);

        }

        /// <summary>
        /// Deletes a tuner host Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Tuner host id (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> PostLivetvTunerhostsDeleteAsyncWithHttpInfo (string id)
        {

            var localVarPath = "/LiveTv/TunerHosts/Delete";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "Id", id)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvTunerhostsDelete", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Resets a tv tuner Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Tuner Id</param>
        /// <returns></returns>
        public void PostLivetvTunersByIdReset (string id)
        {
             PostLivetvTunersByIdResetWithHttpInfo(id);
        }

        /// <summary>
        /// Resets a tv tuner Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Tuner Id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> PostLivetvTunersByIdResetWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->PostLivetvTunersByIdReset");

            var localVarPath = "/LiveTv/Tuners/{Id}/Reset";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvTunersByIdReset", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Resets a tv tuner Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Tuner Id</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task PostLivetvTunersByIdResetAsync (string id)
        {
             await PostLivetvTunersByIdResetAsyncWithHttpInfo(id);

        }

        /// <summary>
        /// Resets a tv tuner Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Tuner Id</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> PostLivetvTunersByIdResetAsyncWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling LiveTvServiceApi->PostLivetvTunersByIdReset");

            var localVarPath = "/LiveTv/Tuners/{Id}/Reset";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("Id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostLivetvTunersByIdReset", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns></returns>
        public void PutLivetvChannelmappingoptions (string providerId)
        {
             PutLivetvChannelmappingoptionsWithHttpInfo(providerId);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> PutLivetvChannelmappingoptionsWithHttpInfo (string providerId)
        {
            // verify the required parameter 'providerId' is set
            if (providerId == null)
                throw new ApiException(400, "Missing required parameter 'providerId' when calling LiveTvServiceApi->PutLivetvChannelmappingoptions");

            var localVarPath = "/LiveTv/ChannelMappingOptions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (providerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ProviderId", providerId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PutLivetvChannelmappingoptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task PutLivetvChannelmappingoptionsAsync (string providerId)
        {
             await PutLivetvChannelmappingoptionsAsyncWithHttpInfo(providerId);

        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> PutLivetvChannelmappingoptionsAsyncWithHttpInfo (string providerId)
        {
            // verify the required parameter 'providerId' is set
            if (providerId == null)
                throw new ApiException(400, "Missing required parameter 'providerId' when calling LiveTvServiceApi->PutLivetvChannelmappingoptions");

            var localVarPath = "/LiveTv/ChannelMappingOptions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (providerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ProviderId", providerId)); // query parameter
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PutLivetvChannelmappingoptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelMapping</param>
        /// <param name="providerId">Provider id</param>
        /// <returns></returns>
        public void PutLivetvChannelmappings (LiveTVApiSetChannelMapping body, string providerId)
        {
             PutLivetvChannelmappingsWithHttpInfo(body, providerId);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelMapping</param>
        /// <param name="providerId">Provider id</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> PutLivetvChannelmappingsWithHttpInfo (LiveTVApiSetChannelMapping body, string providerId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling LiveTvServiceApi->PutLivetvChannelmappings");
            // verify the required parameter 'providerId' is set
            if (providerId == null)
                throw new ApiException(400, "Missing required parameter 'providerId' when calling LiveTvServiceApi->PutLivetvChannelmappings");

            var localVarPath = "/LiveTv/ChannelMappings";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/xml"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (providerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ProviderId", providerId)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PutLivetvChannelmappings", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelMapping</param>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task PutLivetvChannelmappingsAsync (LiveTVApiSetChannelMapping body, string providerId)
        {
             await PutLivetvChannelmappingsAsyncWithHttpInfo(body, providerId);

        }

        /// <summary>
        ///  Requires authentication as administrator
        /// </summary>
        /// <exception cref="EmbyClient.Dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">SetChannelMapping</param>
        /// <param name="providerId">Provider id</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> PutLivetvChannelmappingsAsyncWithHttpInfo (LiveTVApiSetChannelMapping body, string providerId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling LiveTvServiceApi->PutLivetvChannelmappings");
            // verify the required parameter 'providerId' is set
            if (providerId == null)
                throw new ApiException(400, "Missing required parameter 'providerId' when calling LiveTvServiceApi->PutLivetvChannelmappings");

            var localVarPath = "/LiveTv/ChannelMappings";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json", 
                "application/xml"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (providerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ProviderId", providerId)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (apikeyauth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("api_key")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "api_key", this.Configuration.GetApiKeyWithPrefix("api_key")));
            }
            // authentication (embyauth) required
            // bearer required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + this.Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PutLivetvChannelmappings", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

    }
}
